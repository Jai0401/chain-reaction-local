<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction 3D (Responsive V2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Base Styles */
        body { background-color: #000000; color: #e0e0e0; font-family: 'Arial', sans-serif; overflow: hidden; margin: 0; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        canvas { display: block; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }

        /* UI Panels */
        .ui-panel { position: absolute; left: 50%; transform: translateX(-50%); z-index: 10; background-color: rgba(30, 30, 30, 0.9); padding: 1.2rem 1rem; border-radius: 0.75rem; box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2); border: 1px solid rgba(0, 255, 255, 0.5); text-align: center; pointer-events: auto; display: flex; flex-direction: column; align-items: center; width: 90%; max-width: 450px; }
        #setup-screen { top: 50%; transform: translate(-50%, -50%); }
        #game-ui { top: 0.75rem; padding: 0.6rem 0.8rem; max-width: 90%; width: auto; min-width: 260px; display: none; }

        /* UI Elements */
        h2 { color: #ffffff; margin-bottom: 1rem; font-size: 1.3rem; }
        label { color: #00ffff; margin-right: 0.5rem; font-weight: bold; display: block; margin-bottom: 0.25rem; text-align: center; }
        select, button:not(#mute-button) { background-color: #222; color: #00ffff; border: 1px solid #00ffff; padding: 0.7rem 1.2rem; border-radius: 0.375rem; margin: 0.4rem; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s; font-weight: bold; width: 85%; max-width: 280px; box-sizing: border-box; -webkit-appearance: none; -moz-appearance: none; appearance: none; font-size: 0.9rem; }
        @media (hover: hover) and (pointer: fine) { select:hover, button:not(#mute-button):hover { background-color: #333; box-shadow: 0 0 10px #00ffff; } }
        select:focus, button:focus { outline: 2px solid #00ffff; outline-offset: 2px; }
        select { background-image: url('data:image/svg+xml;utf8,<svg fill="%2300ffff" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>'); background-repeat: no-repeat; background-position: right 0.7rem center; padding-right: 2.5rem; text-align: center; text-align-last: center; -moz-text-align-last: center; }

        /* Message Area */
        #message-area { min-height: 35px; padding: 0.5rem 0.7rem; margin-bottom: 0.5rem; font-weight: bold; font-size: 0.95rem; border-radius: 0.375rem; transition: all 0.3s; width: 100%; border: 1px solid transparent; display: flex; align-items: center; justify-content: center; box-sizing: border-box; line-height: 1.2; }

        /* Mute Button */
        #mute-button { position: absolute; top: 0.75rem; right: 0.75rem; z-index: 15; background-color: rgba(34, 34, 34, 0.8); color: #00ffff; border: 1px solid #00ffff; padding: 0.4rem; border-radius: 50%; font-size: 1rem; line-height: 1; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s; display: none; width: 36px; height: 36px; box-sizing: border-box; text-align: center; -webkit-appearance: none; -moz-appearance: none; appearance: none; display: flex; align-items: center; justify-content: center; }
        #mute-button.muted { color: #557777; border-color: #557777; background-color: rgba(34, 34, 34, 0.7); }
        @media (hover: hover) and (pointer: fine) { #mute-button:hover { background-color: #333; box-shadow: 0 0 8px #00ffff; } #mute-button.muted:hover { box-shadow: 0 0 8px #557777; border-color: #00ffff; color: #00ffff; } }

        /* Specific States */
        .winner-message { padding: 0.7rem; font-size: 1rem; animation: pulse 1.5s infinite; border-width: 2px; }
        @keyframes pulse { 0%{box-shadow:0 0 5px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} 50%{box-shadow:0 0 18px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} 100%{box-shadow:0 0 5px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} }
        .hidden { display: none !important; }

        /* Setup Layout */
        .setup-row { display: flex; flex-direction: column; align-items: center; margin-bottom: 0.8rem; width: 100%; }
        .setup-row label { width: auto; text-align: center; margin-right: 0; margin-bottom: 0.15rem; }
        .setup-row select { flex-grow: 0; max-width: 280px; width: 85%; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="setup-screen" class="ui-panel">
            <h2>Game Setup</h2>
            <div class="setup-row"> <label for="player-count">Players:</label> <select id="player-count"> <option value="2">2</option> <option value="3">3</option> <option value="4">4</option> <option value="5">5</option> <option value="6">6</option> <option value="7">7</option> <option value="8">8</option> </select> </div>
            <div class="setup-row"> <label for="grid-size">Grid Size:</label> <select id="grid-size"> <option value="SMALL">Small (5x6)</option> <option value="MEDIUM" selected>Medium (6x8)</option> <option value="LARGE">Large (8x10)</option> </select> </div>
            <button id="start-game-button">Start Game</button>
        </div>
        <div id="game-ui" class="ui-panel"> <div id="message-area"></div> <button id="restart-button" class="hidden">Play Again?</button> </div>
        <div id="canvas-container"> <canvas id="game-canvas"></canvas> </div>
        <button id="mute-button" title="Toggle Sound">ðŸ”Š</button>
    </div>

    <script type="module">
        'use strict';

        // --- Constants ---
        const GRID_SIZES = { SMALL: { rows: 5, cols: 6 }, MEDIUM: { rows: 6, cols: 8 }, LARGE: { rows: 8, cols: 10 } };
        const BASE_CELL_SIZE = 10; // Reference size, used for relative calculations if needed
        const GRID_GAP_FACTOR = 0.1; // Gap size = GRID_GAP_FACTOR * effectiveCellSize
        const ORB_RADIUS_FACTOR = 0.15; // Orb radius = ORB_RADIUS_FACTOR * effectiveCellSize
        const ORB_DETAIL = { segments: 12, rings: 10 };
        const PROJECTILE_RADIUS_FACTOR = 0.12;
        const PROJECTILE_DETAIL = { segments: 10, rings: 8 };
        const EXPLOSION_DELAY_MS = 100;
        const EXPLOSION_SPEED_FACTOR = 7; // Speed = EXPLOSION_SPEED_FACTOR * effectiveCellSize / sec
        const NEUTRAL_GRID_COLOR = 0x555555;
        const CAMERA_FOV = 50; // Vertical FOV in degrees
        const CAMERA_VIEW_PADDING = 1.1; // Multiplier: view will be 110% of grid size
        const NEON_COLORS = [ 0x00ff00, 0x0088ff, 0xff0000, 0xffff00, 0x00ffff, 0xff00ff, 0xff8800, 0xffaaaa ];
        const NEON_COLORS_CSS = [ '#00ff00', '#0088ff', '#ff0000', '#ffff00', '#00ffff', '#ff00ff', '#ff8800', '#ffaaaa' ];

        class ChainReactionGame {
            dom = {}; // Populated in constructor
            scene = null; camera = null; renderer = null; raycaster = null; mouse = null;
            gridGroup = null; gridLineMaterial = null; gridPlaneMesh = null; // Renamed gridMeshGroup -> gridGroup
            orbGroups = {}; // Stores THREE.Group per cell key 'r-c'
            ambientLight = null; directionalLight = null;
            rows = 0; cols = 0; board = []; numPlayers = 2;
            playerColors = []; playerColorsCSS = []; currentPlayer = 1;
            isExploding = false; turnCount = 0; gameOver = false;
            activePlayers = new Set(); animationFrameId = null;
            effectiveCellSize = BASE_CELL_SIZE; // Will be calculated dynamically
            effectiveGapSize = BASE_CELL_SIZE * GRID_GAP_FACTOR;
            cellStep = BASE_CELL_SIZE * (1 + GRID_GAP_FACTOR); // Distance between cell centers
            gridTotalVisualWidth = 0; // Actual width on screen
            gridTotalVisualHeight = 0; // Actual height on screen
            audioContext = null; soundEnabled = false; isMuted = false;
            boundOnCanvasInteraction = this.onCanvasInteraction.bind(this);
            boundOnWindowResize = this.onWindowResize.bind(this);
            boundStartGame = this.startGame.bind(this);
            boundResetGame = this.resetGame.bind(this);
            boundToggleMute = this.toggleMute.bind(this);

            constructor() {
                if (!this.cacheDomElements()) { console.error("Essential DOM elements missing!"); return; }
                this.showSetupScreen();
                this.setupEventListeners();
                console.log("Chain Reaction Game Initialized (Responsive V2)");
            }

            cacheDomElements() {
                this.dom = {
                    setupScreen: document.getElementById('setup-screen'), gameUi: document.getElementById('game-ui'), playerCountSelect: document.getElementById('player-count'), gridSizeSelect: document.getElementById('grid-size'), startGameButton: document.getElementById('start-game-button'), messageArea: document.getElementById('message-area'), restartButton: document.getElementById('restart-button'), canvas: document.getElementById('game-canvas'), canvasContainer: document.getElementById('canvas-container'), gameContainer: document.getElementById('game-container'), muteButton: document.getElementById('mute-button')
                };
                return !!(this.dom.canvas && this.dom.canvasContainer && this.dom.setupScreen && this.dom.gameUi && this.dom.muteButton);
            }

            // --- Setup & Teardown ---
            showSetupScreen() { this.dom.setupScreen.style.display = 'flex'; this.dom.gameUi.style.display = 'none'; this.dom.muteButton.style.display = 'none'; this.dom.restartButton.classList.add('hidden'); }
            setupEventListeners() { this.dom.startGameButton.addEventListener('click', this.boundStartGame); this.dom.restartButton.addEventListener('click', this.boundResetGame); window.addEventListener('resize', this.boundOnWindowResize); this.dom.muteButton.addEventListener('click', this.boundToggleMute); }

            startGame() {
                this.initAudioContext();
                this.numPlayers = parseInt(this.dom.playerCountSelect.value, 10);
                const sizeKey = this.dom.gridSizeSelect.value;
                const size = GRID_SIZES[sizeKey]; this.rows = size.rows; this.cols = size.cols;
                console.log(`Starting game: ${this.numPlayers}p, Grid ${sizeKey} (${this.rows}x${this.cols})`);
                this.dom.setupScreen.style.display = 'none'; this.dom.gameUi.style.display = 'flex'; this.dom.muteButton.style.display = 'flex';
                this.updateMuteButtonVisuals();
                this.initializeGameInternals();
            }

            resetGame() { console.log("Resetting game..."); this.cleanup(); this.showSetupScreen(); }

            initializeGameInternals() {
                this.playerColors = NEON_COLORS.slice(0, this.numPlayers); this.playerColorsCSS = NEON_COLORS_CSS.slice(0, this.numPlayers);
                this.orbGroups = {}; this.currentPlayer = 1; this.isExploding = false; this.turnCount = 0; this.gameOver = false;
                this.activePlayers = new Set(Array.from({ length: this.numPlayers }, (_, i) => i + 1));
                this.initializeBoardState();
                this.setupSceneAndRenderer(); // Creates scene, renderer, camera, lights, raycaster
                this.updateGridAndCameraScale(); // Initial calculation of sizes and camera pos
                this.setupGridVisuals(); // Creates grid lines and plane based on calculated sizes
                this.renderBoard(); // Clears previous orbs (should be none)
                this.updateUI(); this.dom.restartButton.classList.add('hidden');
                this.dom.canvas.addEventListener('pointerdown', this.boundOnCanvasInteraction);
                this.dom.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                this.animate();
                console.log("Game internals initialized.");
            }

            initializeBoardState() { this.board = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ owner: null, count: 0 }))); }

            setupSceneAndRenderer() {
                this.scene = new THREE.Scene();
                this.renderer = new THREE.WebGLRenderer({ canvas: this.dom.canvas, antialias: true, alpha: true });
                this.renderer.setPixelRatio(window.devicePixelRatio); // Size set in updateGridAndCameraScale
                this.camera = new THREE.PerspectiveCamera(CAMERA_FOV, 1, 0.1, 5000); // Aspect ratio set dynamically
                this.scene.add(this.camera);
                this.ambientLight = new THREE.AmbientLight(0xcccccc, 0.8); this.scene.add(this.ambientLight);
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); this.directionalLight.position.set(0.5, 1, 0.75).normalize(); this.scene.add(this.directionalLight);
                this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2();
            }

            // --- Dynamic Scaling & Positioning (REVISED) ---

            updateGridAndCameraScale() {
                if (!this.renderer || !this.camera || !this.dom.canvasContainer) return;

                const containerWidth = this.dom.canvasContainer.clientWidth;
                const containerHeight = this.dom.canvasContainer.clientHeight;

                // 1. Determine Cell Size based on fitting the grid in the container
                // Total grid size includes cells and gaps between them
                // Width = cols * cellSize + (cols - 1) * gapSize = cols * cellSize + (cols - 1) * cellSize * gapFactor = cellSize * (cols + (cols - 1) * gapFactor)
                // Height = cellSize * (rows + (rows - 1) * gapFactor)
                // We use cellStep = cellSize * (1 + gapFactor) for distance between centers
                // Total width ~ cols * cellStep, Height ~ rows * cellStep (approx, more accurate below)

                const gapFactor = GRID_GAP_FACTOR;
                // Calculate required cellSize to fit width and height respectively, leaving padding
                const availableWidth = containerWidth * 0.95; // Use 95% of container
                const availableHeight = containerHeight * 0.90; // Use 90% (leave more space for UI top/bottom)

                // Calculate total spans in terms of cellSize units
                const totalWidthUnits = this.cols + (this.cols - 1) * gapFactor;
                const totalHeightUnits = this.rows + (this.rows - 1) * gapFactor;

                const cellSizeBasedOnWidth = availableWidth / totalWidthUnits;
                const cellSizeBasedOnHeight = availableHeight / totalHeightUnits;

                // Use the smaller cell size to ensure the whole grid fits
                this.effectiveCellSize = Math.max(1, Math.min(cellSizeBasedOnWidth, cellSizeBasedOnHeight));
                this.effectiveGapSize = this.effectiveCellSize * gapFactor;
                this.cellStep = this.effectiveCellSize + this.effectiveGapSize; // Distance between centers

                // Calculate the actual visual size of the grid block (used for camera positioning)
                this.gridTotalVisualWidth = this.cols * this.effectiveCellSize + (this.cols - 1) * this.effectiveGapSize;
                this.gridTotalVisualHeight = this.rows * this.effectiveCellSize + (this.rows - 1) * this.effectiveGapSize;

                // 2. Update Renderer and Camera Aspect Ratio
                this.renderer.setSize(containerWidth, containerHeight);
                this.camera.aspect = containerWidth / containerHeight;

                // 3. Calculate Camera Distance (Z position) - THIS IS THE CRITICAL PART
                const fovRad = THREE.MathUtils.degToRad(this.camera.fov); // Vertical FOV in radians
                const tanFovHalf = Math.tan(fovRad / 2);

                // Calculate distance needed to fit the grid height (with padding)
                const targetHeight = this.gridTotalVisualHeight * CAMERA_VIEW_PADDING;
                const distanceForHeight = (targetHeight / 2) / tanFovHalf;

                // Calculate distance needed to fit the grid width (with padding)
                // We use the relationship: tan(fov_H / 2) = tan(fov_V / 2) * aspect
                const targetWidth = this.gridTotalVisualWidth * CAMERA_VIEW_PADDING;
                const distanceForWidth = (targetWidth / 2) / (tanFovHalf * this.camera.aspect);

                // The camera must be at least the maximum of these distances away
                const baseCameraZ = Math.max(distanceForHeight, distanceForWidth);
                // Add a small base distance so grid isn't exactly filling the padded view, plus ensure minimum distance
                const cameraZ = Math.max(baseCameraZ + this.effectiveCellSize, this.effectiveCellSize * 3);


                // 4. Position Camera and LookAt point
                // Grid origin (bottom-left cell's bottom-left corner) is at (0,0) in the gridGroup
                // Center of the grid block
                const gridCenterX = this.gridTotalVisualWidth / 2;
                const gridCenterY = this.gridTotalVisualHeight / 2;

                this.camera.position.set(
                    gridCenterX,
                    gridCenterY, // No tilt for simplicity first, can add later: + cameraZ * 0.05,
                    cameraZ
                );
                this.camera.lookAt(gridCenterX, gridCenterY, 0); // Look at the center of the grid plane
                this.camera.updateProjectionMatrix(); // Apply aspect ratio and FOV changes

                // 5. Update Grid Plane Mesh for Raycasting (if it exists)
                if (this.gridPlaneMesh) {
                    this.updateGridPlaneGeometry(); // Separate helper for clarity
                }
                 // 6. Update Grid Lines (if they exist)
                if (this.gridGroup) {
                    this.setupGridVisuals(true); // Pass flag to indicate update
                }

                console.log(`Grid Scale Update: CellSize=${this.effectiveCellSize.toFixed(2)}, GridVis=${this.gridTotalVisualWidth.toFixed(1)}x${this.gridTotalVisualHeight.toFixed(1)}, CamZ=${cameraZ.toFixed(1)}`);
            }

            updateGridPlaneGeometry() {
                 if (!this.gridPlaneMesh) return;
                 const planeWidth = this.gridTotalVisualWidth;
                 const planeHeight = this.gridTotalVisualHeight;
                 const gridCenterX = planeWidth / 2;
                 const gridCenterY = planeHeight / 2;

                 this.gridPlaneMesh.geometry.dispose(); // Dispose old geometry
                 this.gridPlaneMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                 this.gridPlaneMesh.position.set(gridCenterX, gridCenterY, -0.01); // Place slightly behind lines/orbs
            }

            // --- Grid Visuals (Simplified Origin) ---

            setupGridVisuals(isUpdate = false) {
                if (this.gridGroup && !isUpdate) {
                    this.scene.remove(this.gridGroup);
                    this.disposeObject(this.gridGroup);
                    this.gridGroup = null;
                    this.gridPlaneMesh = null;
                } else if (this.gridGroup && isUpdate) {
                    // Remove only lines, keep the group and plane (plane geometry updated separately)
                    const linesToRemove = this.gridGroup.children.filter(child => child !== this.gridPlaneMesh);
                    linesToRemove.forEach(line => {
                        this.gridGroup.remove(line);
                        this.disposeObject(line);
                    });
                }

                if (!isUpdate) {
                    this.gridGroup = new THREE.Group();
                    this.gridGroup.name = "GridGroup";
                    this.scene.add(this.gridGroup); // Add group to scene

                    this.gridLineMaterial = new THREE.LineBasicMaterial({
                        color: NEUTRAL_GRID_COLOR, transparent: true, opacity: 0.7
                    });

                    // Invisible Plane for Raycasting (Geometry updated in updateGridPlaneGeometry)
                    const planeGeometry = new THREE.PlaneGeometry(1, 1); // Placeholder size
                    this.gridPlaneMesh = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide }));
                    this.gridPlaneMesh.name = "GridPlane";
                    this.gridGroup.add(this.gridPlaneMesh); // Add plane to the group
                    this.updateGridPlaneGeometry(); // Set initial size and position
                }

                // (Re)Create Grid Lines based on current dimensions, relative to gridGroup origin (0,0)
                const maxX = this.gridTotalVisualWidth;
                const maxY = this.gridTotalVisualHeight;

                // Vertical lines
                for (let i = 0; i <= this.cols; i++) {
                    const x = i * this.cellStep - (this.effectiveGapSize / 2); // Position lines correctly between cells
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, -this.effectiveGapSize / 2, 0),             // Start slightly below bottom edge
                        new THREE.Vector3(x, maxY + this.effectiveGapSize / 2, 0)    // End slightly above top edge
                    ]);
                    this.gridGroup.add(new THREE.Line(geometry, this.gridLineMaterial));
                }
                // Horizontal lines
                for (let i = 0; i <= this.rows; i++) {
                    const y = i * this.cellStep - (this.effectiveGapSize / 2); // Position lines correctly between cells
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                         new THREE.Vector3(-this.effectiveGapSize / 2, y, 0),            // Start slightly left of left edge
                        new THREE.Vector3(maxX + this.effectiveGapSize / 2, y, 0)   // End slightly right of right edge
                    ]);
                    this.gridGroup.add(new THREE.Line(geometry, this.gridLineMaterial));
                }
                // console.log(`Grid visuals ${isUpdate ? 'updated' : 'created'}.`);
            }

            // --- Audio ---
            initAudioContext() { if (this.audioContext) return; try { window.AudioContext = window.AudioContext || window.webkitAudioContext; if (window.AudioContext) { this.audioContext = new AudioContext(); if (this.audioContext.state === 'suspended') { console.log("AudioContext suspended, will try resume on interaction."); } this.soundEnabled = true; console.log("AudioContext initialized."); } else { console.warn("Web Audio API not supported."); this.soundEnabled = false; } } catch (e) { console.error("Error creating AudioContext:", e); this.soundEnabled = false; } }
            playSound(type, freq, duration, volume = 0.3) { if (this.isMuted || !this.soundEnabled || !this.audioContext) return; if (this.audioContext.state === 'suspended') { this.audioContext.resume().then(() => { console.log("AudioContext resumed."); this._executeSound(type, freq, duration, volume); }).catch(e => console.warn("AudioContext resume failed:", e)); return; } if (this.audioContext.state === 'running') { this._executeSound(type, freq, duration, volume); } }
            _executeSound(type, freq, duration, volume) { try { const osc = this.audioContext.createOscillator(); const gainNode = this.audioContext.createGain(); osc.connect(gainNode); gainNode.connect(this.audioContext.destination); osc.type = type; osc.frequency.setValueAtTime(freq, this.audioContext.currentTime); gainNode.gain.setValueAtTime(0, this.audioContext.currentTime); gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.01); gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + duration); osc.start(this.audioContext.currentTime); osc.stop(this.audioContext.currentTime + duration); } catch (e) { console.error("Error playing sound:", e); } }
            playSoundPlace() { this.playSound('triangle', 880, 0.08, 0.15); }
            playSoundExplode() { this.playSound('square', 200, 0.18, 0.25); }
            toggleMute() { this.isMuted = !this.isMuted; console.log("Muted:", this.isMuted); this.updateMuteButtonVisuals(); if (!this.isMuted && this.audioContext && this.audioContext.state === 'suspended') { console.log("Attempting resume AudioContext on unmute."); this.audioContext.resume().catch(e => console.warn("Resume on unmute failed:", e)); } }
            updateMuteButtonVisuals() { if (!this.dom.muteButton) return; this.dom.muteButton.textContent = this.isMuted ? 'ðŸ”‡' : 'ðŸ”Š'; this.dom.muteButton.classList.toggle('muted', this.isMuted); this.dom.muteButton.setAttribute('title', this.isMuted ? 'Unmute Sound' : 'Mute Sound'); }

            // --- Game Logic & Rendering ---
            getCriticalMass = (r, c) => { const isCorner = (r === 0 || r === this.rows - 1) && (c === 0 || c === this.cols - 1); const isEdge = !isCorner && (r === 0 || r === this.rows - 1 || c === 0 || c === this.cols - 1); if (isCorner) return 2; if (isEdge) return 3; return 4; };

            // Calculate cell CENTER position relative to gridGroup origin (0,0)
            getCellCenter(r, c) {
                const x = c * this.cellStep + this.effectiveCellSize / 2;
                // Board row 0 is top, visual Y row 0 is bottom
                const y = (this.rows - 1 - r) * this.cellStep + this.effectiveCellSize / 2;
                return new THREE.Vector3(x, y, 0); // Z is 0, orbs will be slightly offset
            }

            renderCell(r, c) {
                if (!this.gridGroup || !this.board[r]?.[c]) return; // Check gridGroup existence

                const cellState = this.board[r][c];
                const cellKey = `${r}-${c}`;
                const cellCenter = this.getCellCenter(r, c); // Get center position

                // Remove old group for this cell if it exists
                if (this.orbGroups[cellKey]) {
                    this.gridGroup.remove(this.orbGroups[cellKey]); // Remove from parent group
                    this.disposeObject(this.orbGroups[cellKey]); // Dispose contents
                    delete this.orbGroups[cellKey];
                }

                if (cellState.count > 0 && cellState.owner !== null) {
                    const playerIndex = cellState.owner - 1;
                    if (playerIndex < 0 || playerIndex >= this.playerColors.length) return;

                    const color = this.playerColors[playerIndex];
                    const material = new THREE.MeshLambertMaterial({ color: color, emissive: color, emissiveIntensity: 0.4 });

                    const criticalMass = this.getCriticalMass(r, c);
                    const scaleFactor = (cellState.count === criticalMass - 1) ? 1.15 : 1.0;
                    const radius = this.effectiveCellSize * ORB_RADIUS_FACTOR * scaleFactor;
                    const orbGeometry = new THREE.SphereGeometry(radius, ORB_DETAIL.segments, ORB_DETAIL.rings);

                    // Create a new group for this cell's orbs, positioned at cell center
                    const cellOrbGroup = new THREE.Group();
                    cellOrbGroup.position.copy(cellCenter); // Position the group
                    this.orbGroups[cellKey] = cellOrbGroup; // Store reference
                    this.gridGroup.add(cellOrbGroup); // Add to the main grid group

                    // Orb positions *relative* to the cellOrbGroup's center (which is cellCenter)
                    const offset = this.effectiveCellSize * 0.18 * scaleFactor;
                    const positions = [];
                     if (cellState.count === 1) positions.push(new THREE.Vector3(0, 0, radius * 0.5)); // Slightly raise Z
                     else if (cellState.count === 2) { positions.push(new THREE.Vector3(-offset, 0, radius*0.4)); positions.push(new THREE.Vector3(offset, 0, radius*0.6)); }
                     else { const angle = Math.PI*2/3; positions.push(new THREE.Vector3(0, offset, radius*0.5)); positions.push(new THREE.Vector3(offset*Math.sin(angle), offset*Math.cos(angle), radius*0.4)); positions.push(new THREE.Vector3(offset*Math.sin(angle*2), offset*Math.cos(angle*2), radius*0.6)); }

                    for (let i = 0; i < Math.min(cellState.count, 3); i++) {
                        const orbMesh = new THREE.Mesh(orbGeometry, material);
                        orbMesh.position.copy(positions[i]); // Position relative to group center
                        orbMesh.name = `Orb_${r}-${c}_${i}`;
                        cellOrbGroup.add(orbMesh); // Add orb to the cell's group
                    }
                    orbGeometry.dispose(); // Dispose geometry as it's unique per cell render (unless optimized)
                    // Note: material is shared if not cloned, dispose carefully later if needed
                }
            }

            renderBoard() { if (!this.board || !this.gridGroup) return; for (let r=0; r<this.rows; r++) for (let c=0; c<this.cols; c++) this.renderCell(r, c); }

            updateUI() {
                if (!this.dom.messageArea || !this.gridLineMaterial) return;
                const msgArea = this.dom.messageArea; const restartBtn = this.dom.restartButton;
                msgArea.classList.remove('winner-message'); msgArea.style.cssText = ''; msgArea.style.setProperty('--player-color-css', '#ffffff');
                if (this.gameOver) {
                    this.gridLineMaterial.color.setHex(NEUTRAL_GRID_COLOR); msgArea.classList.add('winner-message'); restartBtn.classList.remove('hidden');
                    if (this.activePlayers.size === 1) {
                        const winnerId = [...this.activePlayers][0]; const winnerIndex = winnerId - 1; const winnerColorCSS = this.playerColorsCSS[winnerIndex] || '#ffffff';
                        msgArea.textContent = `Player ${winnerId} Wins!`; msgArea.style.backgroundColor = winnerColorCSS; msgArea.style.color = '#000000'; msgArea.style.borderColor = winnerColorCSS; msgArea.style.setProperty('--player-color-css', winnerColorCSS);
                        restartBtn.style.backgroundColor = winnerColorCSS; restartBtn.style.borderColor = winnerColorCSS; restartBtn.style.color = '#000000'; restartBtn.style.boxShadow = `0 0 10px ${winnerColorCSS}`;
                    } else { msgArea.textContent = `Game Over! Draw or Error.`; msgArea.style.backgroundColor = '#555'; msgArea.style.color = '#fff'; msgArea.style.borderColor = '#777'; msgArea.style.setProperty('--player-color-css', '#777'); restartBtn.style.backgroundColor=''; restartBtn.style.borderColor=''; restartBtn.style.color=''; restartBtn.style.boxShadow=''; }
                } else {
                    const playerIndex = this.currentPlayer - 1; if (playerIndex < 0 || playerIndex >= this.playerColors.length) { console.error("Invalid player index:", playerIndex); this.gridLineMaterial.color.setHex(NEUTRAL_GRID_COLOR); msgArea.textContent="Error"; msgArea.style.backgroundColor='#ff0000'; msgArea.style.color='#ffffff'; return; }
                    const colorHex = this.playerColors[playerIndex]; const colorCSS = this.playerColorsCSS[playerIndex]; this.gridLineMaterial.color.setHex(colorHex); msgArea.textContent = `Player ${this.currentPlayer}'s Turn`; const colorRGB = parseInt(colorCSS.slice(1), 16); const r = (colorRGB>>16)&255; const g = (colorRGB>>8)&255; const b = colorRGB&255; msgArea.style.backgroundColor = `rgba(${r},${g},${b},0.3)`; msgArea.style.color = colorCSS; msgArea.style.border = `1px solid ${colorCSS}`; msgArea.style.boxShadow = `0 0 6px ${colorCSS}`; restartBtn.classList.add('hidden'); restartBtn.style.backgroundColor=''; restartBtn.style.borderColor=''; restartBtn.style.color=''; restartBtn.style.boxShadow='';
                }
            }

            // --- Player Interaction (Revised Raycasting) ---
            onCanvasInteraction(event) {
                if (this.isExploding || this.gameOver || !this.raycaster || !this.camera || !this.gridPlaneMesh || !event.isPrimary) return;
                event.preventDefault();
                const clientX = event.clientX; const clientY = event.clientY;
                const rect = this.dom.canvas.getBoundingClientRect();
                this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);

                // Intersect with the grid plane mesh (which is inside gridGroup)
                const intersects = this.raycaster.intersectObject(this.gridPlaneMesh, false);

                if (intersects.length > 0) {
                    // The intersection point is in world space. Convert it to the gridGroup's local space.
                    const worldIntersectionPoint = intersects[0].point;
                    const localIntersectionPoint = this.gridGroup.worldToLocal(worldIntersectionPoint.clone());

                    // Now, convert the local XY coordinates to grid indices (r, c)
                    // Grid's visual bottom-left is at local (0,0)
                    const c = Math.floor(localIntersectionPoint.x / this.cellStep);
                    const r_visual = Math.floor(localIntersectionPoint.y / this.cellStep); // Visual row (0=bottom)
                    const r = this.rows - 1 - r_visual; // Board row (0=top)

                    if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
                        const cell = this.board[r][c];
                        if (cell.owner === null || cell.owner === this.currentPlayer) { this.placeOrb(r, c); }
                        else { console.log(`Cell (${r}, ${c}) owned by P${cell.owner}.`); }
                    } else { console.log(`Click outside grid bounds (Local: ${localIntersectionPoint.x.toFixed(1)},${localIntersectionPoint.y.toFixed(1)} -> r:${r}, c:${c})`); }
                }
            }

            placeOrb(r, c) {
                if (this.isExploding || this.gameOver) return;
                console.log(`P${this.currentPlayer} places at (${r}, ${c})`); this.playSoundPlace(); this.turnCount++;
                const cell = this.board[r][c]; cell.owner = this.currentPlayer; cell.count++;
                this.renderCell(r, c);
                const criticalMass = this.getCriticalMass(r, c);
                if (cell.count >= criticalMass) { console.log(`Cell (${r}, ${c}) critical.`); this.isExploding = true; this.explodeCell(r, c); }
                else { this.checkPlayerElimination(); this.checkWinCondition(); if (!this.gameOver) this.switchToNextPlayer(); this.updateUI(); }
            }

            switchToNextPlayer() {
                if (this.activePlayers.size <= 1) { if (!this.gameOver) { this.checkWinCondition(); this.updateUI(); } return; }
                let nextPlayer = this.currentPlayer; let attempts = 0; const maxAttempts = this.numPlayers + 1;
                do { nextPlayer = (nextPlayer % this.numPlayers) + 1; attempts++; if (attempts > maxAttempts) { console.error("Infinite loop in switchToNextPlayer!"); this.gameOver = true; return; } } while (!this.activePlayers.has(nextPlayer));
                this.currentPlayer = nextPlayer; console.log(`Switched to P${this.currentPlayer}`);
            }

            // --- Explosion Logic ---
            async explodeCell(r_initial, c_initial) {
                let explosionQueue = [{ r: r_initial, c: c_initial }];
                const projectileGeometry = new THREE.SphereGeometry(this.effectiveCellSize * PROJECTILE_RADIUS_FACTOR, PROJECTILE_DETAIL.segments, PROJECTILE_DETAIL.rings);
                const explosionSpeed = EXPLOSION_SPEED_FACTOR * this.effectiveCellSize; // Speed scaled with cell size

                while (explosionQueue.length > 0) {
                    const currentWaveTasks = []; const nextWaveQueue = []; const nextWaveProcessed = new Set();
                    for (const { r, c } of explosionQueue) {
                        const cell = this.board[r]?.[c]; if (!cell || cell.count < this.getCriticalMass(r, c) || cell.owner === null) continue;
                        this.playSoundExplode();
                        const explodingPlayer = cell.owner; const startPos = this.getCellCenter(r, c); const playerIndex = explodingPlayer - 1; if (playerIndex < 0 || playerIndex >= this.playerColors.length) continue;
                        const color = this.playerColors[playerIndex]; const projectileMaterial = new THREE.MeshLambertMaterial({ color: color, emissive: color, emissiveIntensity: 0.6 });
                        const cellKey = `${r}-${c}`; if (this.orbGroups[cellKey]) { this.gridGroup.remove(this.orbGroups[cellKey]); this.disposeObject(this.orbGroups[cellKey]); delete this.orbGroups[cellKey]; }
                        cell.count = 0; cell.owner = null;
                        const neighbors = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }];
                        for (const { dr, dc } of neighbors) {
                            const nr = r + dr; const nc = c + dc;
                            if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) {
                                const neighborCell = this.board[nr][nc]; const endPos = this.getCellCenter(nr, nc);
                                const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial.clone());
                                // Projectiles are relative to the gridGroup's origin
                                projectile.position.copy(startPos);
                                projectile.name = `Projectile_${r}-${c}_to_${nr}-${nc}`;
                                this.gridGroup.add(projectile); // Add to gridGroup
                                const distance = startPos.distanceTo(endPos); const duration = distance / explosionSpeed;
                                const animPromise = this.animateProjectile(projectile, endPos, duration)
                                    .then(() => { if (projectile.parent) projectile.parent.remove(projectile); this.disposeObject(projectile); neighborCell.owner = explodingPlayer; neighborCell.count++; this.renderCell(nr, nc); const neighborKey = `${nr}-${nc}`; if (neighborCell.count >= this.getCriticalMass(nr, nc) && !nextWaveProcessed.has(neighborKey)) { nextWaveQueue.push({ r: nr, c: nc }); nextWaveProcessed.add(neighborKey); } })
                                    .catch(err => { console.error("Proj anim failed:", err); if(projectile.parent) projectile.parent.remove(projectile); this.disposeObject(projectile); });
                                currentWaveTasks.push(animPromise);
                            }
                        }
                        projectileMaterial.dispose(); // Dispose wave material
                    } // End cell loop
                    if (currentWaveTasks.length > 0) await Promise.all(currentWaveTasks);
                    if (nextWaveQueue.length > 0) await new Promise(res => setTimeout(res, EXPLOSION_DELAY_MS));
                    explosionQueue = nextWaveQueue;
                } // End while
                projectileGeometry.dispose(); this.isExploding = false; console.log("Explosion finished.");
                this.checkPlayerElimination(); this.checkWinCondition();
                if (!this.gameOver && !this.activePlayers.has(this.currentPlayer)) { console.log(`Player ${this.currentPlayer} eliminated, switching.`); this.switchToNextPlayer(); }
                this.updateUI();
            }

            animateProjectile(mesh, targetPos, durationSec) {
                return new Promise((resolve, reject) => {
                    if (!mesh || !targetPos || durationSec <= 0) return reject(new Error("Invalid proj params"));
                    const startPos = mesh.position.clone(); let startTime = null;
                    const step = (timestamp) => { if (!mesh || !mesh.parent) return resolve(); if (!startTime) startTime = timestamp; const elapsed = (timestamp - startTime) / 1000; const progress = Math.min(elapsed / durationSec, 1.0); mesh.position.lerpVectors(startPos, targetPos, progress); if (progress < 1) requestAnimationFrame(step); else resolve(); };
                    requestAnimationFrame(step);
                });
            }

            // --- Game State Checks ---
            checkPlayerElimination() { if (this.turnCount < this.numPlayers) return; const playersWithOrbs = new Set(); for (let r = 0; r < this.rows; r++) for (let c = 0; c < this.cols; c++) if (this.board[r][c].owner !== null) playersWithOrbs.add(this.board[r][c].owner); const playersToRemove = []; for (const playerNum of this.activePlayers) if (!playersWithOrbs.has(playerNum)) playersToRemove.push(playerNum); if (playersToRemove.length > 0) playersToRemove.forEach(p => { this.activePlayers.delete(p); console.log(`Player ${p} eliminated.`); }); }
            checkWinCondition() { if (this.gameOver || this.turnCount < this.numPlayers) return; if (this.activePlayers.size === 1) { this.gameOver = true; console.log(`Game Over: P${[...this.activePlayers][0]} wins!`); } else if (this.activePlayers.size === 0) { this.gameOver = true; console.log("Game Over: Draw!"); } }

            // --- Animation Loop & Resize ---
            animate() { this.animationFrameId = requestAnimationFrame(this.animate.bind(this)); if (this.renderer && this.scene && this.camera) this.renderer.render(this.scene, this.camera); }
            onWindowResize() { console.log("Window resize detected."); this.updateGridAndCameraScale(); this.renderBoard(); /* Re-render needed if orb sizes changed */ }

            // --- Cleanup ---
            cleanup() {
                console.log("Cleaning up game resources..."); if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null;
                this.dom.canvas.removeEventListener('pointerdown', this.boundOnCanvasInteraction); this.dom.canvas.removeEventListener('contextmenu', (e) => e.preventDefault()); // Might need reference if complex
                if (this.audioContext && this.audioContext.state !== 'closed') { this.audioContext.close().then(() => console.log("AudioContext closed.")).catch(e=>console.error("Err closing AudioContext:",e)); } this.audioContext = null; this.soundEnabled = false;
                if (this.scene) { if (this.gridLineMaterial) this.gridLineMaterial.dispose(); while(this.scene.children.length > 0){ const object = this.scene.children[0]; this.scene.remove(object); this.disposeObject(object); } }
                if (this.renderer) { this.renderer.dispose(); this.renderer.domElement = null; }
                this.scene = null; this.camera = null; this.renderer = null; this.raycaster = null; this.mouse = null; this.gridGroup = null; this.gridLineMaterial = null; this.gridPlaneMesh = null; this.orbGroups = {}; this.board = []; this.activePlayers.clear(); this.ambientLight = null; this.directionalLight = null;
                console.log("Cleanup complete.");
            }

            disposeObject(obj) {
                if (!obj) return;
                if (obj.children && obj.children.length > 0) { [...obj.children].forEach(child => { this.disposeObject(child); if(obj.remove) obj.remove(child); }); }
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) { if (Array.isArray(obj.material)) obj.material.forEach(m => m && m.dispose()); else obj.material.dispose(); }
                if (obj.texture) obj.texture.dispose(); // Basic texture disposal if needed
                // Do NOT remove obj from its parent here, parent should do that before calling disposeObject on child
            }
        } // End ChainReactionGame Class

        // --- Instantiate ---
        document.addEventListener('DOMContentLoaded', () => {
            window.chainReactionGame = new ChainReactionGame();
        });
    </script>
</body>
</html>