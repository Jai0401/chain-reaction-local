<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction 3D (w/ Mute)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Base Styles */
        body {
            background-color: #000000; color: #e0e0e0; font-family: 'Arial', sans-serif;
            overflow: hidden; margin: 0;
            -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none;
            -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none;
            -ms-user-select: none; user-select: none;
        }
        canvas { display: block; touch-action: none; }

        /* Containers */
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }

        /* UI Panels */
        .ui-panel {
            position: absolute; left: 50%; transform: translateX(-50%); z-index: 10;
            background-color: rgba(30, 30, 30, 0.9); padding: 1.5rem 1rem;
            border-radius: 0.75rem; box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.5); text-align: center;
            pointer-events: auto; display: flex; flex-direction: column;
            align-items: center; width: 90%; max-width: 480px;
        }
        #setup-screen { top: 50%; transform: translate(-50%, -50%); }
        #game-ui { top: 1rem; padding: 0.75rem 1rem; max-width: 550px; width: auto; min-width: 280px; display: none; }

        /* UI Elements */
        h2 { color: #ffffff; margin-bottom: 1rem; font-size: 1.4rem; }
        label { color: #00ffff; margin-right: 0.5rem; font-weight: bold; display: block; margin-bottom: 0.25rem; text-align: center; }
        select, button:not(#mute-button) { /* Exclude mute button from general width rules */
            background-color: #222; color: #00ffff; border: 1px solid #00ffff;
            padding: 0.8rem 1.5rem; border-radius: 0.375rem; margin: 0.5rem;
            cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s;
            font-weight: bold; width: 80%; max-width: 250px; box-sizing: border-box;
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
        @media (hover: hover) and (pointer: fine) {
            select:hover, button:hover { background-color: #333; box-shadow: 0 0 10px #00ffff; }
        }
        select:focus, button:focus { outline: 2px solid #00ffff; outline-offset: 2px; }
        select {
             background-image: url('data:image/svg+xml;utf8,<svg fill="%2300ffff" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
             background-repeat: no-repeat; background-position: right 0.75rem center; padding-right: 2.5rem;
             text-align: center; text-align-last: center; -moz-text-align-last: center;
        }

        /* Message Area */
        #message-area {
            min-height: 40px; padding: 0.6rem 0.75rem; margin-bottom: 0.75rem; font-weight: bold;
            font-size: 1.0rem; border-radius: 0.375rem; transition: all 0.3s; width: 100%;
            border: 1px solid transparent; display: flex; align-items: center; justify-content: center; box-sizing: border-box;
        }

        /* Mute Button */
        #mute-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 15; /* Above other UI */
            background-color: rgba(34, 34, 34, 0.8); /* Slightly transparent background */
            color: #00ffff;
            border: 1px solid #00ffff;
            padding: 0.4rem 0.6rem; /* Smaller padding */
            border-radius: 50%; /* Circular */
            font-size: 1.2rem; /* Adjust emoji size */
            line-height: 1; /* Ensure emoji fits */
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s;
            display: none; /* Hidden initially */
            width: 40px; /* Fixed size */
            height: 40px; /* Fixed size */
            box-sizing: border-box;
            text-align: center;
             -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
        #mute-button.muted {
            color: #557777; /* Dimmed cyan */
            border-color: #557777;
            background-color: rgba(34, 34, 34, 0.7);
        }
        @media (hover: hover) and (pointer: fine) {
            #mute-button:hover {
                background-color: #333;
                box-shadow: 0 0 8px #00ffff;
            }
            #mute-button.muted:hover {
                box-shadow: 0 0 8px #557777;
                border-color: #00ffff; /* Highlight border on hover even when muted */
                color: #00ffff;
            }
        }


        /* Specific States */
        .winner-message { padding: 0.8rem; font-size: 1.1rem; animation: pulse 1.5s infinite; border-width: 2px; }
        @keyframes pulse { /* ... (no change) ... */
            0%{box-shadow:0 0 5px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)}50%{box-shadow:0 0 20px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)}100%{box-shadow:0 0 5px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)}
        }
        .hidden { display: none !important; }

        /* Setup Layout */
        .setup-row { display: flex; flex-direction: column; align-items: center; margin-bottom: 1rem; width: 100%; }
        .setup-row label { width: auto; text-align: center; margin-right: 0; }
        .setup-row select { flex-grow: 0; max-width: 250px; width: 80%; }

    </style>
</head>
<body>

    <div id="game-container">
        <!-- UI Elements (Setup, Game UI, Canvas Container) -->
        <div id="setup-screen" class="ui-panel">
            <h2>Game Setup</h2>
            <div class="setup-row">
                <label for="player-count">Players:</label>
                <select id="player-count">
                    <option value="2">2</option> <option value="3">3</option> <option value="4">4</option>
                    <option value="5">5</option> <option value="6">6</option> <option value="7">7</option> <option value="8">8</option>
                </select>
            </div>
            <div class="setup-row">
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size">
                    <option value="SMALL">Small (5x6)</option> <option value="MEDIUM" selected>Medium (6x8)</option> <option value="LARGE">Large (8x10)</option>
                </select>
            </div>
            <button id="start-game-button">Start Game</button>
        </div>
        <div id="game-ui" class="ui-panel">
             <div id="message-area"></div>
             <button id="restart-button" class="hidden">Play Again?</button>
        </div>
        <div id="canvas-container"> <canvas id="game-canvas"></canvas> </div>

        <!-- Mute Button - Outside main UI panels but inside game container -->
        <button id="mute-button" title="Toggle Sound">ðŸ”Š</button>

    </div>

    <script>
        'use strict';

        class ChainReactionGame {
            // Constants (no change)
            static GRID_SIZES = { SMALL: { rows: 5, cols: 6 }, MEDIUM: { rows: 6, cols: 8 }, LARGE: { rows: 8, cols: 10 } };
            static CELL_SIZE = 10; static GRID_GAP = 1; static ORB_RADIUS_BASE = ChainReactionGame.CELL_SIZE * 0.15;
            static EXPLOSION_DELAY_MS = 100; static EXPLOSION_SPEED = 50; static NEUTRAL_GRID_COLOR = 0x555555;
            static NEON_COLORS = [ 0x00ff00, 0x0088ff, 0xff0000, 0xffff00, 0x00ffff, 0xff00ff, 0xff8800, 0xffaaaa ];
            static NEON_COLORS_CSS = [ '#00ff00', '#0088ff', '#ff0000', '#ffff00', '#00ffff', '#ff00ff', '#ff8800', '#ffaaaa' ];

            // DOM Elements
            dom = {
                setupScreen: document.getElementById('setup-screen'), gameUi: document.getElementById('game-ui'),
                playerCountSelect: document.getElementById('player-count'), gridSizeSelect: document.getElementById('grid-size'),
                startGameButton: document.getElementById('start-game-button'), messageArea: document.getElementById('message-area'),
                restartButton: document.getElementById('restart-button'), canvas: document.getElementById('game-canvas'),
                canvasContainer: document.getElementById('canvas-container'), gameContainer: document.getElementById('game-container'),
                muteButton: document.getElementById('mute-button') // Added mute button
            };

            // Three.js Objects (no change)
            scene = null; camera = null; renderer = null; raycaster = null; mouse = null; gridMeshGroup = null; gridLineMaterial = null; orbMeshes = {}; ambientLight = null; directionalLight = null;

            // Game State (no change)
            rows = 0; cols = 0; board = []; numPlayers = 2; playerColors = []; playerColorsCSS = []; currentPlayer = 1; isExploding = false; turnCount = 0; gameOver = false; activePlayers = new Set(); animationFrameId = null;

            // Audio State
            audioContext = null;
            soundEnabled = false; // Tracks if context is *capable* of playing sound
            isMuted = false; // User preference for muting

            // Event Listeners (bound)
            boundOnCanvasInteraction = this.onCanvasInteraction.bind(this);
            boundOnWindowResize = this.onWindowResize.bind(this);
            boundStartGame = this.startGame.bind(this);
            boundResetGame = this.resetGame.bind(this);
            boundToggleMute = this.toggleMute.bind(this); // Added for mute button

            constructor() {
                if (!this.dom.canvas || !this.dom.canvasContainer) { console.error("Canvas elements missing!"); return; }
                if (!this.dom.muteButton) { console.error("Mute button element missing!"); } // Added check
                this.showSetupScreen();
                this.setupEventListeners();
            }

            showSetupScreen() {
                this.dom.setupScreen.style.display = 'flex';
                this.dom.gameUi.style.display = 'none';
                this.dom.muteButton.style.display = 'none'; // Hide mute button on setup
            }

            setupEventListeners() {
                this.dom.startGameButton.addEventListener('click', this.boundStartGame);
                this.dom.restartButton.addEventListener('click', this.boundResetGame);
                window.addEventListener('resize', this.boundOnWindowResize);
                this.dom.muteButton.addEventListener('click', this.boundToggleMute); // Add listener for mute
                // Canvas listeners added when game starts
            }

            initAudioContext() { /* ... (no change) ... */
                if (this.audioContext) return; try { window.AudioContext = window.AudioContext || window.webkitAudioContext; if (window.AudioContext) { this.audioContext = new AudioContext(); if (this.audioContext.state === 'suspended') { this.audioContext.resume(); } this.soundEnabled = true; console.log("AudioContext initialized."); } else { console.warn("Web Audio API not supported."); this.soundEnabled = false; } } catch (e) { console.error("Error creating AudioContext:", e); this.soundEnabled = false; }
            }

            playSound(type, freq, duration, volume = 0.3) {
                // --- Check Mute status first ---
                if (this.isMuted) return;

                if (!this.soundEnabled || !this.audioContext || this.audioContext.state !== 'running') {
                    if (this.audioContext && this.audioContext.state === 'suspended') { this.audioContext.resume(); } return;
                }
                try { /* ... (sound playing logic unchanged) ... */
                    const osc = this.audioContext.createOscillator(); const gainNode = this.audioContext.createGain(); osc.connect(gainNode); gainNode.connect(this.audioContext.destination); osc.type = type; osc.frequency.setValueAtTime(freq, this.audioContext.currentTime); gainNode.gain.setValueAtTime(0, this.audioContext.currentTime); gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.01); gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + duration); osc.start(this.audioContext.currentTime); osc.stop(this.audioContext.currentTime + duration);
                } catch (e) { console.error("Error playing sound:", e); }
            }
            playSoundPlace() { this.playSound('triangle', 880, 0.08, 0.2); }
            playSoundExplode() { this.playSound('square', 220, 0.15, 0.35); }


            // --- Mute Functionality ---
            toggleMute() {
                this.isMuted = !this.isMuted;
                console.log("Muted:", this.isMuted);
                this.updateMuteButtonVisuals();

                // If unmuting, try to ensure the audio context is running
                if (!this.isMuted && this.audioContext && this.audioContext.state === 'suspended') {
                    console.log("Attempting to resume AudioContext on unmute.");
                    this.audioContext.resume();
                }
            }

            updateMuteButtonVisuals() {
                if (!this.dom.muteButton) return;
                this.dom.muteButton.textContent = this.isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
                if (this.isMuted) {
                    this.dom.muteButton.classList.add('muted');
                    this.dom.muteButton.setAttribute('title', 'Unmute Sound');
                } else {
                    this.dom.muteButton.classList.remove('muted');
                    this.dom.muteButton.setAttribute('title', 'Mute Sound');
                }
            }

            // --- Game Lifecycle ---
            startGame() {
                this.initAudioContext(); // Attempt to init/resume audio

                this.numPlayers = parseInt(this.dom.playerCountSelect.value, 10);
                const size = ChainReactionGame.GRID_SIZES[this.dom.gridSizeSelect.value];
                this.rows = size.rows; this.cols = size.cols;
                console.log(`Starting game: ${this.numPlayers}p, ${this.rows}x${this.cols}, Sound Capable: ${this.soundEnabled}, Muted: ${this.isMuted}`);
                this.dom.setupScreen.style.display = 'none';
                this.dom.gameUi.style.display = 'flex';
                this.dom.muteButton.style.display = 'block'; // Show mute button
                this.updateMuteButtonVisuals(); // Set initial mute button state

                this.initializeGameInternals();
            }

            resetGame() {
                console.log("Resetting game...");
                this.cleanup();
                this.showSetupScreen(); // Hides mute button via this method
            }

            initializeGameInternals() {
                // Reset State (no change)
                this.playerColors = ChainReactionGame.NEON_COLORS.slice(0, this.numPlayers); this.playerColorsCSS = ChainReactionGame.NEON_COLORS_CSS.slice(0, this.numPlayers); this.orbMeshes = {}; this.currentPlayer = 1; this.isExploding = false; this.turnCount = 0; this.gameOver = false; this.activePlayers = new Set(Array.from({ length: this.numPlayers }, (_, i) => i + 1));

                this.initializeBoardState(); this.setupScene(); this.setupGridMesh();
                this.renderBoard(); this.updateUI(); this.dom.restartButton.classList.add('hidden');

                // Add Input Listeners (no change)
                this.dom.canvas.addEventListener('touchend', this.boundOnCanvasInteraction, { passive: false });
                this.dom.canvas.addEventListener('click', this.boundOnCanvasInteraction);

                this.animate();
            }

            initializeBoardState() { /* ... (no change) ... */ this.board = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ owner: null, count: 0 }))); }
            setupScene() { /* ... (no change) ... */ this.scene = new THREE.Scene(); const aspect = this.dom.canvasContainer.clientWidth / this.dom.canvasContainer.clientHeight; this.camera = new THREE.PerspectiveCamera(50, aspect, 1, 3000); const gridWidth = this.cols * (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP) - ChainReactionGame.GRID_GAP; const gridHeight = this.rows * (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP) - ChainReactionGame.GRID_GAP; const cameraZ = Math.max(gridWidth, gridHeight) * 1.5; const cameraY = gridHeight * 0.5 + cameraZ * 0.1; const cameraX = gridWidth * 0.5; this.camera.position.set(cameraX, cameraY, cameraZ); this.camera.lookAt(cameraX, gridHeight * 0.5, 0); this.scene.add(this.camera); this.renderer = new THREE.WebGLRenderer({ canvas: this.dom.canvas, antialias: true, alpha: true }); this.renderer.setSize(this.dom.canvasContainer.clientWidth, this.dom.canvasContainer.clientHeight); this.renderer.setPixelRatio(window.devicePixelRatio); this.ambientLight = new THREE.AmbientLight(0xcccccc); this.scene.add(this.ambientLight); this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); this.directionalLight.position.set(0.5, 1, 0.75).normalize(); this.scene.add(this.directionalLight); this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2(); }
            setupGridMesh() { /* ... (no change) ... */ this.gridMeshGroup = new THREE.Group(); this.gridMeshGroup.name = "GridGroup"; this.gridLineMaterial = new THREE.LineBasicMaterial({ color: ChainReactionGame.NEUTRAL_GRID_COLOR, transparent: true, opacity: 0.75 }); const gridWidth = this.cols * (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP) - ChainReactionGame.GRID_GAP; const gridHeight = this.rows * (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP) - ChainReactionGame.GRID_GAP; const halfGap = ChainReactionGame.GRID_GAP / 2; for (let i = 0; i <= this.cols; i++) { const x = i * (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP) - halfGap; const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, -halfGap, 0), new THREE.Vector3(x, gridHeight + halfGap, 0)]); this.gridMeshGroup.add(new THREE.Line(geometry, this.gridLineMaterial)); } for (let i = 0; i <= this.rows; i++) { const y = i * (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP) - halfGap; const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-halfGap, y, 0), new THREE.Vector3(gridWidth + halfGap, y, 0)]); this.gridMeshGroup.add(new THREE.Line(geometry, this.gridLineMaterial)); } const planeGeometry = new THREE.PlaneGeometry(gridWidth + ChainReactionGame.GRID_GAP, gridHeight + ChainReactionGame.GRID_GAP); const planeMesh = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide })); planeMesh.position.set(gridWidth / 2, gridHeight / 2, -0.1); planeMesh.name = "GridPlane"; this.gridMeshGroup.add(planeMesh); this.scene.add(this.gridMeshGroup); }

            cleanup() { /* ... (Audio context close added) ... */
                console.log("Cleaning up resources..."); if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null;
                this.dom.canvas.removeEventListener('touchend', this.boundOnCanvasInteraction); this.dom.canvas.removeEventListener('click', this.boundOnCanvasInteraction);
                // --- Close Audio Context ---
                if (this.audioContext && this.audioContext.state !== 'closed') { this.audioContext.close().then(() => console.log("AudioContext closed.")).catch(e=>console.error("Err closing AudioContext:",e)); } this.audioContext = null; this.soundEnabled = false;
                 // Dispose Three.js (no change)
                 if (this.scene) { while(this.scene.children.length > 0){ this.disposeObject(this.scene.children[0]); this.scene.remove(this.scene.children[0]); } } if (this.renderer) this.renderer.dispose(); this.renderer = null; this.scene = null; this.camera = null; this.raycaster = null; this.mouse = null; this.gridMeshGroup = null; this.gridLineMaterial = null; this.orbMeshes = {}; this.board = []; this.activePlayers.clear(); console.log("Cleanup complete.");
            }
            disposeObject(obj) { /* ... (no change) ... */ if (!obj) return; if (obj.geometry) obj.geometry.dispose(); if (obj.material) { if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose()); else obj.material.dispose(); } if (obj.children) [...obj.children].forEach(child => this.disposeObject(child)); if (typeof obj.dispose === 'function' && !(obj instanceof THREE.Scene)) obj.dispose(); }

            // --- Game Logic & Rendering (Sound calls added) ---

            getCriticalMass = (r, c) => { /* ... (no change) ... */ const isCorner = (r === 0 || r === this.rows - 1) && (c === 0 || c === this.cols - 1); const isEdge = !isCorner && (r === 0 || r === this.rows - 1 || c === 0 || c === this.cols - 1); if (isCorner) return 2; if (isEdge) return 3; return 4; };
            getCellCenter = (r, c) => { /* ... (no change) ... */ const x = c * (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP) + ChainReactionGame.CELL_SIZE / 2; const visualY = (this.rows - 1 - r) * (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP) + ChainReactionGame.CELL_SIZE / 2; return new THREE.Vector3(x, visualY, 0); };
            renderCell(r, c) { /* ... (no change) ... */ if (!this.scene || !this.board[r]?.[c]) return; const cellState = this.board[r][c]; const cellKey = `${r}-${c}`; if (this.orbMeshes[cellKey]) this.orbMeshes[cellKey].forEach(orb => orb && this.scene.remove(orb)); this.orbMeshes[cellKey] = []; if (cellState.count > 0 && cellState.owner !== null) { const playerIndex = cellState.owner - 1; if (playerIndex < 0 || playerIndex >= this.playerColors.length) return; const color = this.playerColors[playerIndex]; const material = new THREE.MeshLambertMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 }); const cellCenter = this.getCellCenter(r, c); const criticalMass = this.getCriticalMass(r, c); const scaleFactor = (cellState.count === criticalMass - 1) ? 1.2 : 1.0; const radius = ChainReactionGame.ORB_RADIUS_BASE * scaleFactor; const orbGeometry = new THREE.SphereGeometry(radius, 16, 12); const positions = []; const offset = ChainReactionGame.CELL_SIZE * 0.15; const offsetMd = ChainReactionGame.CELL_SIZE * 0.13; const offsetVNeg = ChainReactionGame.CELL_SIZE * 0.1; if (cellState.count === 1) positions.push(new THREE.Vector3(0, 0, radius)); else if (cellState.count === 2) { positions.push(new THREE.Vector3(-offset, 0, radius)); positions.push(new THREE.Vector3(offset, 0, radius)); } else { positions.push(new THREE.Vector3(0, offset, radius)); positions.push(new THREE.Vector3(-offsetMd, -offsetVNeg, radius)); positions.push(new THREE.Vector3(offsetMd, -offsetVNeg, radius)); } for (let i = 0; i < Math.min(cellState.count, 3); i++) { const orbMesh = new THREE.Mesh(orbGeometry, material); orbMesh.position.copy(cellCenter).add(positions[i]); orbMesh.name = `Orb_${r}-${c}_${i}`; this.scene.add(orbMesh); this.orbMeshes[cellKey].push(orbMesh); } } }
            renderBoard() { /* ... (no change) ... */ if (!this.board) return; for (let r = 0; r < this.rows; r++) for (let c = 0; c < this.cols; c++) this.renderCell(r, c); }
            updateUI() { /* ... (no change) ... */ if (!this.dom.messageArea || !this.gridLineMaterial) return; const msgArea = this.dom.messageArea; const restartBtn = this.dom.restartButton; msgArea.classList.remove('winner-message'); msgArea.style.cssText = ''; msgArea.style.setProperty('--player-color-css', '#ffffff'); if (this.gameOver) { this.gridLineMaterial.color.setHex(ChainReactionGame.NEUTRAL_GRID_COLOR); msgArea.classList.add('winner-message'); restartBtn.classList.remove('hidden'); if (this.activePlayers.size === 1) { const winnerId = [...this.activePlayers][0]; const winnerIndex = winnerId - 1; const winnerColorCSS = this.playerColorsCSS[winnerIndex] || '#ffffff'; msgArea.textContent = `Player ${winnerId} Wins!`; msgArea.style.backgroundColor = winnerColorCSS; msgArea.style.color = '#000000'; msgArea.style.borderColor = winnerColorCSS; msgArea.style.setProperty('--player-color-css', winnerColorCSS); restartBtn.style.backgroundColor = winnerColorCSS; restartBtn.style.borderColor = winnerColorCSS; restartBtn.style.color = '#000000'; restartBtn.style.boxShadow = `0 0 10px ${winnerColorCSS}`; } else { msgArea.textContent = `Game Over!`; msgArea.style.backgroundColor = '#555'; msgArea.style.color = '#fff'; msgArea.style.borderColor = '#777'; msgArea.style.setProperty('--player-color-css', '#777'); restartBtn.style.backgroundColor = '#555'; restartBtn.style.borderColor = '#777'; restartBtn.style.color = '#fff'; restartBtn.style.boxShadow = 'none'; } } else { const playerIndex = this.currentPlayer - 1; if (playerIndex < 0 || playerIndex >= this.playerColors.length) { console.error("Invalid player index:", playerIndex); this.gridLineMaterial.color.setHex(ChainReactionGame.NEUTRAL_GRID_COLOR); msgArea.textContent = "Error"; msgArea.style.backgroundColor = '#ff0000'; msgArea.style.color = '#ffffff'; return; } const colorHex = this.playerColors[playerIndex]; const colorCSS = this.playerColorsCSS[playerIndex]; this.gridLineMaterial.color.setHex(colorHex); msgArea.textContent = `Player ${this.currentPlayer}'s Turn`; msgArea.style.backgroundColor = `rgba(${parseInt(colorCSS.slice(1, 3), 16)}, ${parseInt(colorCSS.slice(3, 5), 16)}, ${parseInt(colorCSS.slice(5, 7), 16)}, 0.4)`; msgArea.style.color = colorCSS; msgArea.style.border = `1px solid ${colorCSS}`; msgArea.style.boxShadow = `0 0 8px ${colorCSS}`; restartBtn.classList.add('hidden'); } }

            onCanvasInteraction(event) { /* ... (no change) ... */ if (this.isExploding || this.gameOver || !this.raycaster || !this.camera || !this.scene) return; if (event.type === 'touchend' || event.type === 'touchstart') event.preventDefault(); let clientX, clientY; if (event.changedTouches && event.changedTouches.length > 0) { clientX = event.changedTouches[0].clientX; clientY = event.changedTouches[0].clientY; } else if (event.clientX !== undefined && event.clientY !== undefined) { clientX = event.clientX; clientY = event.clientY; } else { console.warn("No coords from event:", event.type); return; } const rect = this.dom.canvas.getBoundingClientRect(); this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1; this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1; this.raycaster.setFromCamera(this.mouse, this.camera); const intersects = this.raycaster.intersectObjects(this.gridMeshGroup.children, false); const gridPlaneIntersect = intersects.find(i => i.object.name === "GridPlane"); if (gridPlaneIntersect) { const point = gridPlaneIntersect.point; const c = Math.floor(point.x / (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP)); const r_visual = Math.floor(point.y / (ChainReactionGame.CELL_SIZE + ChainReactionGame.GRID_GAP)); const r = this.rows - 1 - r_visual; if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) { const cell = this.board[r][c]; if (cell.owner === null || cell.owner === this.currentPlayer) { this.placeOrb(r, c); } else { console.log(`Cell (${r}, ${c}) owned by P${cell.owner}.`); } } else { console.log(`Interaction outside grid: (${r}, ${c})`); } } }

            placeOrb(r, c) { /* ... (playSoundPlace added) ... */
                if (this.isExploding || this.gameOver) return;
                console.log(`P${this.currentPlayer} places at (${r}, ${c})`);
                this.playSoundPlace(); // Play sound
                this.turnCount++; const cell = this.board[r][c]; cell.owner = this.currentPlayer; cell.count++; this.renderCell(r, c);
                const criticalMass = this.getCriticalMass(r, c);
                if (cell.count >= criticalMass) { console.log(`Cell (${r}, ${c}) critical.`); this.isExploding = true; this.explodeCell(r, c); }
                else { this.checkPlayerElimination(); this.checkWinCondition(); if (!this.gameOver) this.switchToNextPlayer(); this.updateUI(); }
            }
            switchToNextPlayer() { /* ... (no change) ... */ if (this.activePlayers.size <= 1) { if (!this.gameOver) { this.gameOver = true; this.checkWinCondition(); this.updateUI(); } return; } let nextPlayer = this.currentPlayer; let attempts = 0; do { nextPlayer = (nextPlayer % this.numPlayers) + 1; attempts++; } while (!this.activePlayers.has(nextPlayer) && attempts <= this.numPlayers); if (this.activePlayers.has(nextPlayer)) { this.currentPlayer = nextPlayer; console.log(`Switched to P${this.currentPlayer}`); } else { console.error("Could not find next player!", this.activePlayers); this.gameOver = true; } }

            async explodeCell(r_initial, c_initial) { /* ... (playSoundExplode added) ... */
                let explosionQueue = [{ r: r_initial, c: c_initial }]; let processedInWave = new Set([`${r_initial}-${c_initial}`]); const projectileGeometry = new THREE.SphereGeometry(ChainReactionGame.ORB_RADIUS_BASE * 0.8, 12, 10);
                while (explosionQueue.length > 0) {
                    const currentWaveTasks = []; const nextWaveQueue = []; const nextWaveProcessed = new Set();
                    for (const { r, c } of explosionQueue) {
                        const cell = this.board[r]?.[c]; if (!cell || cell.count < this.getCriticalMass(r, c) || cell.owner === null) continue;
                        this.playSoundExplode(); // Play sound for this cell exploding
                        const explodingPlayer = cell.owner; const startPos = this.getCellCenter(r, c); const playerIndex = explodingPlayer - 1; if (playerIndex < 0 || playerIndex >= this.playerColors.length) continue; const color = this.playerColors[playerIndex]; const projectileMaterial = new THREE.MeshLambertMaterial({ color: color, emissive: color, emissiveIntensity: 0.6 }); const cellKey = `${r}-${c}`; if (this.orbMeshes[cellKey]) this.orbMeshes[cellKey].forEach(orb => this.scene.remove(orb)); this.orbMeshes[cellKey] = []; cell.count = 0; cell.owner = null; const neighbors = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }];
                        for (const { dr, dc } of neighbors) { const nr = r + dr; const nc = c + dc; if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) { const neighborCell = this.board[nr][nc]; const endPos = this.getCellCenter(nr, nc); const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial); projectile.position.copy(startPos); projectile.name = `Projectile_${r}-${c}_to_${nr}-${nc}`; this.scene.add(projectile); const distance = startPos.distanceTo(endPos); const duration = distance / ChainReactionGame.EXPLOSION_SPEED; currentWaveTasks.push( this.animateProjectile(projectile, endPos, duration).then(() => { if (this.scene) this.scene.remove(projectile); neighborCell.owner = explodingPlayer; neighborCell.count++; this.renderCell(nr, nc); const neighborKey = `${nr}-${nc}`; if (neighborCell.count >= this.getCriticalMass(nr, nc) && !nextWaveProcessed.has(neighborKey)) { nextWaveQueue.push({ r: nr, c: nc }); nextWaveProcessed.add(neighborKey); } }).catch(err => { console.error("Projectile anim failed:", err); if(this.scene && projectile) this.scene.remove(projectile); }) ); } }
                    } // End cell loop
                    if (currentWaveTasks.length > 0) await Promise.all(currentWaveTasks); if (nextWaveQueue.length > 0) await new Promise(res => setTimeout(res, ChainReactionGame.EXPLOSION_DELAY_MS)); explosionQueue = nextWaveQueue; processedInWave = nextWaveProcessed;
                } // End while
                projectileGeometry.dispose(); this.isExploding = false; console.log("Explosion finished."); this.checkPlayerElimination(); this.checkWinCondition(); if (!this.gameOver) this.switchToNextPlayer(); this.updateUI();
            }
            animateProjectile(mesh, targetPos, durationSec) { /* ... (no change) ... */ return new Promise((resolve, reject) => { if (!mesh || !targetPos || durationSec <= 0) return reject(new Error("Invalid params")); const startPos = mesh.position.clone(); let startTime = null; const step = (timestamp) => { if (!mesh || !mesh.parent) return resolve(); if (!startTime) startTime = timestamp; const elapsed = (timestamp - startTime) / 1000; const progress = Math.min(elapsed / durationSec, 1.0); mesh.position.lerpVectors(startPos, targetPos, progress); if (progress < 1) requestAnimationFrame(step); else resolve(); }; requestAnimationFrame(step); }); }
            checkPlayerElimination() { /* ... (no change) ... */ if (this.turnCount < this.numPlayers && !this.isExploding) return; const playersWithOrbs = new Set(); for (let r = 0; r < this.rows; r++) for (let c = 0; c < this.cols; c++) if (this.board[r][c].owner !== null) playersWithOrbs.add(this.board[r][c].owner); const playersToRemove = []; for (const playerNum of this.activePlayers) if (!playersWithOrbs.has(playerNum)) playersToRemove.push(playerNum); if (playersToRemove.length > 0) playersToRemove.forEach(p => { this.activePlayers.delete(p); console.log(`Player ${p} eliminated.`); }); }
            checkWinCondition() { /* ... (no change) ... */ if (this.gameOver || this.turnCount < this.numPlayers) return; if (this.activePlayers.size === 1) { this.gameOver = true; console.log(`Game Over: P${[...this.activePlayers][0]} wins!`); } else if (this.activePlayers.size === 0) { this.gameOver = true; console.log("Game Over: Draw!"); } }

            // --- Animation Loop & Resize ---
            animate() { /* ... (no change) ... */ this.animationFrameId = requestAnimationFrame(this.animate.bind(this)); if (this.renderer && this.scene && this.camera) this.renderer.render(this.scene, this.camera); }
            onWindowResize() { /* ... (no change) ... */ if (!this.camera || !this.renderer || !this.dom.canvasContainer) return; const width = this.dom.canvasContainer.clientWidth; const height = this.dom.canvasContainer.clientHeight; this.camera.aspect = width / height; this.camera.updateProjectionMatrix(); this.renderer.setSize(width, height); console.log(`Resized to ${width}x${height}`); }
        }

        // --- Instantiate ---
        document.addEventListener('DOMContentLoaded', () => {
            const game = new ChainReactionGame();
            window.chainReactionGame = game;
        });
    </script>

</body>
</html>