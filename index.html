<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction 3D (Mobile Friendly)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Base Styles */
        body { background-color: #000000; color: #e0e0e0; font-family: 'Arial', sans-serif; overflow: hidden; margin: 0; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        canvas { display: block; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }

        /* UI Panels */
        .ui-panel { position: absolute; left: 50%; transform: translateX(-50%); z-index: 10; background-color: rgba(30, 30, 30, 0.9); padding: 1.2rem 1rem; border-radius: 0.75rem; box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2); border: 1px solid rgba(0, 255, 255, 0.5); text-align: center; pointer-events: auto; display: flex; flex-direction: column; align-items: center; width: 90%; max-width: 450px; }
        #setup-screen { top: 50%; transform: translate(-50%, -50%); }
        /* Game UI panel is initially hidden and positioned at top for game over state */
        #game-ui { top: 0.75rem; padding: 0.6rem 0.8rem; max-width: 90%; width: auto; min-width: 260px; display: none; }

        /* UI Elements */
        h2 { color: #ffffff; margin-bottom: 1rem; font-size: 1.3rem; }
        label { color: #00ffff; margin-right: 0.5rem; font-weight: bold; display: block; margin-bottom: 0.25rem; text-align: center; }
        select, button:not(#mute-button) { background-color: #222; color: #00ffff; border: 1px solid #00ffff; padding: 0.7rem 1.2rem; border-radius: 0.375rem; margin: 0.4rem; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s; font-weight: bold; width: 85%; max-width: 280px; box-sizing: border-box; -webkit-appearance: none; -moz-appearance: none; appearance: none; font-size: 0.9rem; }
        @media (hover: hover) and (pointer: fine) { select:hover, button:not(#mute-button):hover { background-color: #333; box-shadow: 0 0 10px #00ffff; } }
        select:focus, button:focus { outline: 2px solid #00ffff; outline-offset: 2px; }
        select { background-image: url('data:image/svg+xml;utf8,<svg fill="%2300ffff" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>'); background-repeat: no-repeat; background-position: right 0.7rem center; padding-right: 2.5rem; text-align: center; text-align-last: center; -moz-text-align-last: center; }

        /* Message Area (within Game UI panel, only shown on game over) */
        #message-area { min-height: 35px; padding: 0.5rem 0.7rem; margin-bottom: 0.5rem; font-weight: bold; font-size: 0.95rem; border-radius: 0.375rem; transition: all 0.3s; width: 100%; border: 1px solid transparent; display: flex; align-items: center; justify-content: center; box-sizing: border-box; line-height: 1.2; }

        /* Mute Button */
        #mute-button { position: relative; z-index: 15; background-color: rgba(34, 34, 34, 0.8); color: #00ffff; border: 1px solid #00ffff; padding: 0.4rem; border-radius: 50%; font-size: 1rem; line-height: 1; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s; display: flex; align-items: center; justify-content: center; }
        #mute-button.muted { color: #557777; border-color: #557777; background-color: rgba(34, 34, 34, 0.7); }
        @media (hover: hover) and (pointer: fine) { #mute-button:hover { background-color: #333; box-shadow: 0 0 8px #00ffff; } #mute-button.muted:hover { box-shadow: 0 0 8px #557777; border-color: #00ffff; color: #00ffff; } }

        /* Fullscreen Button */
        #fullscreen-button { margin-top: 0.5rem; display: flex; align-items: center; justify-content: center; }
        #fullscreen-button:before { content: "ðŸ“±"; margin-right: 0.5rem; }

        /* Specific States */
        .winner-message { padding: 0.7rem; font-size: 1rem; animation: pulse 1.5s infinite; border-width: 2px; }
        @keyframes pulse { 0%{box-shadow:0 0 5px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} 50%{box-shadow:0 0 18px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} 100%{box-shadow:0 0 5px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} }
        .hidden { display: none !important; }

        /* Setup Layout */
        .setup-row { display: flex; flex-direction: column; align-items: center; margin-bottom: 0.8rem; width: 100%; }
        .setup-row label { width: auto; text-align: center; margin-right: 0; margin-bottom: 0.15rem; }
        .setup-row select { flex-grow: 0; max-width: 280px; width: 85%; }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Setup Screen (visible initially) -->
        <div id="setup-screen" class="ui-panel">
            <h2>Game Setup</h2>
            <!-- Mute Button (Now in settings) -->
            <button id="mute-button" title="Toggle Sound">ðŸ”Š</button>
            
            <!-- Fullscreen Button (for mobile devices) -->
            <button id="fullscreen-button">Fullscreen Mode</button>
            
            <div class="setup-row">
                <label for="player-count">Players:</label>
                <select id="player-count">
                    <option value="2">2</option> <option value="3">3</option> <option value="4">4</option>
                    <option value="5">5</option> <option value="6">6</option> <option value="7">7</option> <option value="8">8</option>
                </select>
            </div>
            <div class="setup-row">
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <button id="start-game-button">Start Game</button>
        </div>

        <!-- Game UI Panel (Only shown on Game Over) -->
        <div id="game-ui" class="ui-panel">
             <div id="message-area"></div> <!-- Message area for winner display -->
             <button id="restart-button" class="hidden">Play Again?</button>
        </div>

        <!-- Canvas Container (Always visible) -->
        <div id="canvas-container"> <canvas id="game-canvas"></canvas> </div>

    </div>

    <script type="module">
        'use strict';
        // --- Constants ---
        const GRID_SIZES = {
            SMALL:           { rows: 5, cols: 6, label: "Small (5x6)" },
            PORTRAIT_SMALL:  { rows: 8, cols: 5, label: "Portrait S (8x5)" },
            MEDIUM:          { rows: 6, cols: 8, label: "Medium (6x8)" },
            PORTRAIT_MEDIUM: { rows: 12, cols: 6, label: "Portrait M (12x6)" },
            LARGE:           { rows: 8, cols: 10, label: "Large (8x10)" }
        };
        const DEFAULT_GRID_SIZE_DESKTOP = 'MEDIUM';
        const DEFAULT_GRID_SIZE_MOBILE = 'PORTRAIT_MEDIUM';
        const GRID_GAP_FACTOR = 0.2; // Gap between cells as percentage of cell size
        const MOBILE_BREAKPOINT = 768; // Define what counts as a mobile device
        const BASE_CELL_SIZE = 10;
        const ORB_RADIUS_FACTOR = 0.22; // Increased base size for orbs
        const ORB_DETAIL = { segments: 12, rings: 10 };
        const PROJECTILE_RADIUS_FACTOR = 0.12;
        const PROJECTILE_DETAIL = { segments: 10, rings: 8 };
        const EXPLOSION_DELAY_MS = 100;
        const EXPLOSION_SPEED_FACTOR = 7;
        const NEUTRAL_GRID_COLOR = 0x555555;
        const CAMERA_FOV = 50;
        const CAMERA_VIEW_PADDING = 1.1;
        const NEON_COLORS = [ 0x00ff00, 0x0088ff, 0xff0000, 0xffff00, 0x00ffff, 0xff00ff, 0xff8800, 0xffaaaa ];
        const NEON_COLORS_CSS = [ '#00ff00', '#0088ff', '#ff0000', '#ffff00', '#00ffff', '#ff00ff', '#ff8800', '#ffaaaa' ];

        class ChainReactionGame {
            dom = {};
            scene = null; camera = null; renderer = null; raycaster = null; mouse = null;
            gridGroup = null; gridLineMaterial = null; gridPlaneMesh = null;
            orbGroups = {};
            ambientLight = null; directionalLight = null;
            rows = 0; cols = 0; board = []; numPlayers = 2;
            playerColors = []; playerColorsCSS = []; currentPlayer = 1;
            isExploding = false; turnCount = 0; gameOver = false;
            activePlayers = new Set(); animationFrameId = null;
            effectiveCellSize = BASE_CELL_SIZE;
            effectiveGapSize = BASE_CELL_SIZE * GRID_GAP_FACTOR;
            cellStep = BASE_CELL_SIZE * (1 + GRID_GAP_FACTOR);
            gridTotalVisualWidth = 0; gridTotalVisualHeight = 0;
            audioContext = null; soundEnabled = false; isMuted = false;
            boundOnCanvasInteraction = this.onCanvasInteraction.bind(this);
            boundOnWindowResize = this.onWindowResize.bind(this);
            boundStartGame = this.startGame.bind(this);
            boundResetGame = this.resetGame.bind(this);
            boundToggleMute = this.toggleMute.bind(this);
            clock = null;

            constructor() {
                if (!this.cacheDomElements()) { console.error("Essential DOM elements missing!"); return; }
                this.populateGridSizeDropdown();
                this.setDefaultGridSize();
                this.showSetupScreen(); // Initially show setup
                this.setupEventListeners();
                
                // Initialize animation clock
                this.clock = new THREE.Clock();
                
                // Check if device is mobile-sized
                this.checkAndShowFullscreenOption();
                
                console.log("Chain Reaction Game Initialized (Mobile Friendly)");
            }

            cacheDomElements() {
                this.dom = {
                    setupScreen: document.getElementById('setup-screen'),
                    gameUi: document.getElementById('game-ui'), // The panel shown on game over
                    messageArea: document.getElementById('message-area'),
                    canvas: document.getElementById('game-canvas'),
                    startGameButton: document.getElementById('start-game-button'),
                    restartButton: document.getElementById('restart-button'),
                    playerCountSelect: document.getElementById('player-count'),
                    gridSizeSelect: document.getElementById('grid-size'),
                    muteButton: document.getElementById('mute-button'),
                    fullscreenButton: document.getElementById('fullscreen-button'),
                    canvasContainer: document.getElementById('canvas-container'),
                    gameContainer: document.getElementById('game-container')
                };
                // Ensure all critical elements are found
                return Object.values(this.dom).every(el => el !== null);
            }

            populateGridSizeDropdown() {
                const selectElement = this.dom.gridSizeSelect;
                if (!selectElement) return;
                selectElement.innerHTML = '';
                for (const key in GRID_SIZES) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = GRID_SIZES[key].label;
                    selectElement.appendChild(option);
                }
            }

            setDefaultGridSize() {
                const selectElement = this.dom.gridSizeSelect;
                if (!selectElement) return;
                const isMobile = this.isMobileDevice();
                const defaultKey = isMobile ? DEFAULT_GRID_SIZE_MOBILE : DEFAULT_GRID_SIZE_DESKTOP;
                if (GRID_SIZES[defaultKey]) {
                    selectElement.value = defaultKey;
                    console.log(`Setting default grid size to: ${defaultKey} (Mobile: ${isMobile})`);
                } else {
                    console.warn(`Default grid size key "${defaultKey}" not found. Using first option.`);
                    selectElement.selectedIndex = 0;
                }
            }

            showSetupScreen() {
                this.dom.setupScreen.style.display = 'flex';
                this.dom.gameUi.style.display = 'none'; // Hide game over UI
                this.dom.muteButton.style.display = 'flex'; // Show mute button in settings
                if (this.dom.restartButton) this.dom.restartButton.classList.add('hidden');
                if (this.dom.messageArea) this.dom.messageArea.textContent = '';
            }

            setupEventListeners() {
                this.dom.startGameButton.addEventListener('click', this.boundStartGame);
                this.dom.restartButton.addEventListener('click', this.boundResetGame);
                window.addEventListener('resize', this.boundOnWindowResize);
                this.dom.muteButton.addEventListener('click', this.boundToggleMute);
                
                // Add fullscreen event listener if supported
                if (this.dom.fullscreenButton && document.documentElement.requestFullscreen) {
                    this.dom.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
                }
            }

            startGame() {
                this.initAudioContext();
                this.numPlayers = parseInt(this.dom.playerCountSelect.value, 10);
                let sizeKey = this.dom.gridSizeSelect.value;
                if (!GRID_SIZES[sizeKey]) {
                    console.error(`Invalid grid size key selected: ${sizeKey}. Defaulting.`);
                    this.dom.gridSizeSelect.selectedIndex = 0;
                    sizeKey = this.dom.gridSizeSelect.value;
                     if (!GRID_SIZES[sizeKey]) { alert("Error: Could not determine grid size."); return; }
                }
                const size = GRID_SIZES[sizeKey];
                this.rows = size.rows; this.cols = size.cols;

                console.log(`Starting game: ${this.numPlayers}p, Grid ${sizeKey} (${this.rows}x${this.cols})`);
                this.dom.setupScreen.style.display = 'none'; // Hide setup
                this.dom.gameUi.style.display = 'none'; // << HIDE game UI panel during play
                this.dom.muteButton.style.display = 'none'; // Hide mute button
                this.updateMuteButtonVisuals();
                this.initializeGameInternals();
            }

            resetGame() {
                console.log("Resetting game...");
                this.cleanup();
                this.showSetupScreen(); // Go back to setup screen
            }

            initializeGameInternals() {
                this.playerColors = NEON_COLORS.slice(0, this.numPlayers);
                this.playerColorsCSS = NEON_COLORS_CSS.slice(0, this.numPlayers);
                this.orbGroups = {}; this.currentPlayer = 1; this.isExploding = false;
                this.turnCount = 0; this.gameOver = false;
                this.activePlayers = new Set(Array.from({ length: this.numPlayers }, (_, i) => i + 1));
                this.initializeBoardState();
                this.setupSceneAndRenderer();
                this.updateGridAndCameraScale();
                this.setupGridVisuals();
                this.renderBoard();
                this.updateUI(); // Initial UI update (will hide #game-ui)
                if (this.dom.restartButton) this.dom.restartButton.classList.add('hidden'); // Ensure hidden at start
                this.dom.canvas.addEventListener('pointerdown', this.boundOnCanvasInteraction);
                this.dom.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                this.animate();
                console.log("Game internals initialized.");
            }

            initializeBoardState() { this.board = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ owner: null, count: 0 }))); }

            setupSceneAndRenderer() {
                this.scene = new THREE.Scene();
                this.renderer = new THREE.WebGLRenderer({ canvas: this.dom.canvas, antialias: true, alpha: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.camera = new THREE.PerspectiveCamera(CAMERA_FOV, 1, 0.1, 5000); this.scene.add(this.camera);
                this.ambientLight = new THREE.AmbientLight(0xcccccc, 0.8); this.scene.add(this.ambientLight);
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); this.directionalLight.position.set(0.5, 1, 0.75).normalize(); this.scene.add(this.directionalLight);
                this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2();
            }

            updateGridAndCameraScale() {
                if (!this.renderer || !this.camera || !this.dom.canvasContainer) return;
                const containerWidth = this.dom.canvasContainer.clientWidth; const containerHeight = this.dom.canvasContainer.clientHeight;
                const gapFactor = GRID_GAP_FACTOR;
                const availableWidth = containerWidth * 0.95; const availableHeight = containerHeight * 0.95; // Use more height now
                const totalWidthUnits = this.cols + (this.cols - 1) * gapFactor; const totalHeightUnits = this.rows + (this.rows - 1) * gapFactor;
                const cellSizeBasedOnWidth = availableWidth / totalWidthUnits; const cellSizeBasedOnHeight = availableHeight / totalHeightUnits;
                this.effectiveCellSize = Math.max(1, Math.min(cellSizeBasedOnWidth, cellSizeBasedOnHeight));
                this.effectiveGapSize = this.effectiveCellSize * gapFactor; this.cellStep = this.effectiveCellSize + this.effectiveGapSize;
                this.gridTotalVisualWidth = this.cols * this.effectiveCellSize + (this.cols - 1) * this.effectiveGapSize;
                this.gridTotalVisualHeight = this.rows * this.effectiveCellSize + (this.rows - 1) * this.effectiveGapSize;
                this.renderer.setSize(containerWidth, containerHeight); this.camera.aspect = containerWidth / containerHeight;
                const fovRad = THREE.MathUtils.degToRad(this.camera.fov); const tanFovHalf = Math.tan(fovRad / 2);
                const targetHeight = this.gridTotalVisualHeight * CAMERA_VIEW_PADDING; const distanceForHeight = (targetHeight / 2) / tanFovHalf;
                const targetWidth = this.gridTotalVisualWidth * CAMERA_VIEW_PADDING; const distanceForWidth = (targetWidth / 2) / (tanFovHalf * this.camera.aspect);
                const baseCameraZ = Math.max(distanceForHeight, distanceForWidth); const cameraZ = Math.max(baseCameraZ + this.effectiveCellSize, this.effectiveCellSize * 3);
                const gridCenterX = this.gridTotalVisualWidth / 2; const gridCenterY = this.gridTotalVisualHeight / 2;
                this.camera.position.set(gridCenterX, gridCenterY, cameraZ); this.camera.lookAt(gridCenterX, gridCenterY, 0);
                this.camera.updateProjectionMatrix();
                if (this.gridPlaneMesh) { this.updateGridPlaneGeometry(); }
                if (this.gridGroup) { this.setupGridVisuals(true); }
            }

            updateGridPlaneGeometry() {
                 if (!this.gridPlaneMesh) return;
                 const planeWidth = this.gridTotalVisualWidth; const planeHeight = this.gridTotalVisualHeight;
                 const gridCenterX = planeWidth / 2; const gridCenterY = planeHeight / 2;
                 this.gridPlaneMesh.geometry.dispose();
                 this.gridPlaneMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                 this.gridPlaneMesh.position.set(gridCenterX, gridCenterY, -0.01);
            }

            setupGridVisuals(isUpdate = false) {
                if (this.gridGroup && !isUpdate) { this.scene.remove(this.gridGroup); this.disposeObject(this.gridGroup); this.gridGroup = null; this.gridPlaneMesh = null; }
                else if (this.gridGroup && isUpdate) { const linesToRemove = this.gridGroup.children.filter(child => child !== this.gridPlaneMesh); linesToRemove.forEach(line => { this.gridGroup.remove(line); this.disposeObject(line); }); }
                if (!isUpdate) {
                    this.gridGroup = new THREE.Group(); this.gridGroup.name = "GridGroup"; this.scene.add(this.gridGroup);
                    this.gridLineMaterial = new THREE.LineBasicMaterial({ color: NEUTRAL_GRID_COLOR, transparent: true, opacity: 0.7 });
                    const planeGeometry = new THREE.PlaneGeometry(1, 1); this.gridPlaneMesh = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide })); this.gridPlaneMesh.name = "GridPlane"; this.gridGroup.add(this.gridPlaneMesh); this.updateGridPlaneGeometry();
                }
                const maxX = this.gridTotalVisualWidth; const maxY = this.gridTotalVisualHeight;
                for (let i = 0; i <= this.cols; i++) { const x = i * this.cellStep - (this.effectiveGapSize / 2); const geom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, -this.effectiveGapSize/2, 0), new THREE.Vector3(x, maxY + this.effectiveGapSize/2, 0)]); this.gridGroup.add(new THREE.Line(geom, this.gridLineMaterial)); }
                for (let i = 0; i <= this.rows; i++) { const y = i * this.cellStep - (this.effectiveGapSize / 2); const geom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-this.effectiveGapSize/2, y, 0), new THREE.Vector3(maxX + this.effectiveGapSize/2, y, 0)]); this.gridGroup.add(new THREE.Line(geom, this.gridLineMaterial)); }
            }

            initAudioContext() { if(this.audioContext)return;try{window.AudioContext=window.AudioContext||window.webkitAudioContext;if(window.AudioContext){this.audioContext=new AudioContext();if(this.audioContext.state==='suspended'){console.log("AudioContext suspended, will try resume on interaction.");}this.soundEnabled=true;console.log("AudioContext initialized.");}else{console.warn("Web Audio API not supported.");this.soundEnabled=false;}}catch(e){console.error("Error creating AudioContext:",e);this.soundEnabled=false;}}
            playSound(t,f,d,v=0.3){if(this.isMuted||!this.soundEnabled||!this.audioContext)return;if(this.audioContext.state==='suspended'){this.audioContext.resume().then(()=>{console.log("AudioContext resumed.");this._executeSound(t,f,d,v);}).catch(e=>console.warn("AudioContext resume failed:",e));return;}if(this.audioContext.state==='running'){this._executeSound(t,f,d,v);}}
            _executeSound(t,f,d,v){try{const o=this.audioContext.createOscillator();const g=this.audioContext.createGain();o.connect(g);g.connect(this.audioContext.destination);o.type=t;o.frequency.setValueAtTime(f,this.audioContext.currentTime);g.gain.setValueAtTime(0,this.audioContext.currentTime);g.gain.linearRampToValueAtTime(v,this.audioContext.currentTime+0.01);g.gain.linearRampToValueAtTime(0,this.audioContext.currentTime+d);o.start(this.audioContext.currentTime);o.stop(this.audioContext.currentTime+d);}catch(e){console.error("Error playing sound:",e);}}
            playSoundPlace(){this.playSound('triangle',880,0.08,0.15);}
            playSoundExplode(){this.playSound('square',200,0.18,0.25);}
            toggleMute(){this.isMuted=!this.isMuted;console.log("Muted:",this.isMuted);this.updateMuteButtonVisuals();if(!this.isMuted&&this.audioContext&&this.audioContext.state==='suspended'){console.log("Attempting resume AudioContext on unmute.");this.audioContext.resume().catch(e=>console.warn("Resume on unmute failed:",e));}}
            updateMuteButtonVisuals(){if(!this.dom.muteButton)return;this.dom.muteButton.textContent=this.isMuted?'ðŸ”‡':'ðŸ”Š';this.dom.muteButton.classList.toggle('muted',this.isMuted);this.dom.muteButton.setAttribute('title',this.isMuted?'Unmute Sound':'Mute Sound');}

            getCriticalMass=(r,c)=>{const iC=(r===0||r===this.rows-1)&&(c===0||c===this.cols-1);const iE=!iC&&(r===0||r===this.rows-1||c===0||c===this.cols-1);if(iC)return 2;if(iE)return 3;return 4;};
            getCellCenter(r,c){const x=c*this.cellStep+this.effectiveCellSize/2;const y=(this.rows-1-r)*this.cellStep+this.effectiveCellSize/2;return new THREE.Vector3(x,y,0);}

            renderCell(r, c) {
                if (!this.gridGroup || !this.board[r]?.[c]) return;
                const cellState = this.board[r][c]; const cellKey = `${r}-${c}`; const cellCenter = this.getCellCenter(r, c);
                if (this.orbGroups[cellKey]) { this.gridGroup.remove(this.orbGroups[cellKey]); this.disposeObject(this.orbGroups[cellKey]); delete this.orbGroups[cellKey]; }
                if (cellState.count > 0 && cellState.owner !== null) {
                    const playerIndex = cellState.owner - 1; if (playerIndex < 0 || playerIndex >= this.playerColors.length) return;
                    const color = this.playerColors[playerIndex]; const material = new THREE.MeshLambertMaterial({ color: color, emissive: color, emissiveIntensity: 0.4 });
                    const criticalMass = this.getCriticalMass(r, c);
                    let scaleFactor = 1.0;
                    if (cellState.count === 1) {
                        scaleFactor = 1.2; // Bigger single orbs
                    } else if (cellState.count === criticalMass - 1) {
                        scaleFactor = 1.15; // Slightly bigger when about to explode
                    } else if (cellState.count === 2) {
                        scaleFactor = 1.1; // Medium size for two orbs
                    }
                    const radius = this.effectiveCellSize * ORB_RADIUS_FACTOR * scaleFactor; const orbGeometry = new THREE.SphereGeometry(radius, ORB_DETAIL.segments, ORB_DETAIL.rings);
                    const cellOrbGroup = new THREE.Group(); cellOrbGroup.position.copy(cellCenter); this.orbGroups[cellKey] = cellOrbGroup; this.gridGroup.add(cellOrbGroup);
                    const baseOffset = this.effectiveCellSize * 0.2; // Increased base offset for more spacing
                    const offset = baseOffset * (cellState.count === 2 ? 0.95 : 0.9); // Increased spacing between orbs
                    const positions = [];
                    if (cellState.count === 1) positions.push(new THREE.Vector3(0, 0, radius*0.5));
                    else if (cellState.count === 2) { 
                        positions.push(new THREE.Vector3(-offset/2, 0, radius*0.4)); 
                        positions.push(new THREE.Vector3(offset/2, 0, radius*0.6)); 
                    }
                    else { 
                        // More spaced out triangle formation for 3 orbs
                        const a = Math.PI*2/3;
                        const triangleOffset = offset * 0.9; // Increased triangle spacing
                        positions.push(new THREE.Vector3(0, triangleOffset*0.9, radius*0.5));
                        positions.push(new THREE.Vector3(triangleOffset*Math.sin(a), triangleOffset*Math.cos(a), radius*0.4));
                        positions.push(new THREE.Vector3(triangleOffset*Math.sin(a*2), triangleOffset*Math.cos(a*2), radius*0.6));
                    }
                    
                    // Calculate animation speed based on proximity to critical mass
                    const stabilityRatio = cellState.count / criticalMass;
                    let animationSpeed;
                    if (stabilityRatio >= 0.99) { // About to explode
                        animationSpeed = 3.0; // Fastest
                    } else if (stabilityRatio >= 0.66) { // Getting unstable
                        animationSpeed = 2.0; // Medium
                    } else { // Stable
                        animationSpeed = 1.0; // Slowest
                    }
                    
                    // Store animation data with the orb group
                    cellOrbGroup.userData = {
                        basePositions: positions.map(p => p.clone()),
                        animationSpeed: animationSpeed,
                        orbCount: cellState.count
                    };

                    for (let i = 0; i < Math.min(cellState.count, 3); i++) { 
                        const orbMesh = new THREE.Mesh(orbGeometry, material); 
                        orbMesh.position.copy(positions[i]); 
                        orbMesh.name = `Orb_${r}-${c}_${i}`; 
                        cellOrbGroup.add(orbMesh); 
                    }
                    orbGeometry.dispose(); // Dispose geometry after creating meshes
                }
            }

            renderBoard() { if (!this.board || !this.gridGroup) return; for(let r=0; r<this.rows; r++) for(let c=0; c<this.cols; c++) this.renderCell(r,c); }

            updateUI() {
                if(!this.dom.messageArea || !this.gridLineMaterial || !this.dom.gameUi || !this.dom.restartButton) return;
                const msgArea = this.dom.messageArea;
                const restartBtn = this.dom.restartButton;
                const gameUiPanel = this.dom.gameUi;

                msgArea.classList.remove('winner-message');
                msgArea.style.cssText = ''; // Clear inline styles
                msgArea.style.setProperty('--player-color-css','#ffffff');
                msgArea.textContent = ''; // Clear text

                if(this.gameOver) {
                    gameUiPanel.style.display = 'flex'; // << SHOW game UI panel on game over
                    this.gridLineMaterial.color.setHex(NEUTRAL_GRID_COLOR);
                    msgArea.classList.add('winner-message');
                    restartBtn.classList.remove('hidden');

                    if(this.activePlayers.size === 1) {
                        const winner = [...this.activePlayers][0];
                        const winnerIndex = winner - 1;
                        const winnerColorCSS = this.playerColorsCSS[winnerIndex] || '#ffffff';
                        msgArea.textContent = `Player ${winner} Wins!`;
                        msgArea.style.backgroundColor = winnerColorCSS;
                        msgArea.style.color = '#000000';
                        msgArea.style.borderColor = winnerColorCSS;
                        msgArea.style.setProperty('--player-color-css', winnerColorCSS);
                        restartBtn.style.backgroundColor = winnerColorCSS;
                        restartBtn.style.borderColor = winnerColorCSS;
                        restartBtn.style.color = '#000000';
                        restartBtn.style.boxShadow = `0 0 10px ${winnerColorCSS}`;
                    } else {
                        msgArea.textContent = `Game Over! Draw or Error.`;
                        msgArea.style.backgroundColor = '#555';
                        msgArea.style.color = '#fff';
                        msgArea.style.borderColor = '#777';
                        msgArea.style.setProperty('--player-color-css', '#777');
                        restartBtn.style.backgroundColor = ''; restartBtn.style.borderColor = ''; restartBtn.style.color = ''; restartBtn.style.boxShadow = '';
                    }
                } else {
                    gameUiPanel.style.display = 'none'; // << HIDE game UI panel during active play
                    const playerIndex = this.currentPlayer - 1;
                    if(playerIndex < 0 || playerIndex >= this.playerColors.length) {
                        console.error("Invalid player index:", playerIndex);
                        this.gridLineMaterial.color.setHex(NEUTRAL_GRID_COLOR);
                        return;
                    }
                    const playerColorHex = this.playerColors[playerIndex];
                    this.gridLineMaterial.color.setHex(playerColorHex); // Update grid line color only
                    restartBtn.classList.add('hidden'); // Ensure restart button is hidden
                }
            }

            onCanvasInteraction(event) {
                if(this.isExploding || this.gameOver || !this.raycaster || !this.camera || !this.gridPlaneMesh || !event.isPrimary) return;
                event.preventDefault();
                const x = event.clientX; const y = event.clientY;
                const rect = this.dom.canvas.getBoundingClientRect();
                this.mouse.x = ( (x - rect.left) / rect.width ) * 2 - 1;
                this.mouse.y = - ( (y - rect.top) / rect.height ) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.gridPlaneMesh, false);
                if(intersects.length > 0) {
                    const worldPoint = intersects[0].point;
                    const localPoint = this.gridGroup.worldToLocal(worldPoint.clone());
                    const col = Math.floor(localPoint.x / this.cellStep);
                    const row_visual = Math.floor(localPoint.y / this.cellStep);
                    const row = this.rows - 1 - row_visual;

                    if(row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                        const cellState = this.board[row][col];
                        if(cellState.owner === null || cellState.owner === this.currentPlayer) {
                            this.placeOrb(row, col); // Async function handles the rest
                        } else {
                            console.log(`Cell (${row}, ${col}) owned by P${cellState.owner}.`);
                        }
                    } else {
                        console.log(`Click outside grid (Local: ${localPoint.x.toFixed(1)},${localPoint.y.toFixed(1)} -> r:${row}, c:${col})`);
                    }
                }
            }

            async placeOrb(r, c) {
                if (this.isExploding || this.gameOver) return;

                console.log(`P${this.currentPlayer} places at (${r}, ${c})`);
                this.playSoundPlace();
                this.turnCount++;

                const cellState = this.board[r][c];
                cellState.owner = this.currentPlayer;
                cellState.count++;
                this.renderCell(r, c); // Render immediately

                const criticalMass = this.getCriticalMass(r, c);

                if (cellState.count >= criticalMass) {
                    console.log(`Cell (${r}, ${c}) critical. Starting explosion.`);
                    this.isExploding = true; // Lock input
                    await this.explodeCell(r, c); // Wait for explosion chain
                    // Explosion finished, now check state and switch turn
                    this.checkPlayerElimination();
                    this.checkWinCondition();
                    if (!this.gameOver) {
                        this.switchToNextPlayer();
                    }
                } else {
                    // No explosion, check state and switch turn
                    this.checkPlayerElimination();
                    this.checkWinCondition();
                     if (!this.gameOver) {
                        this.switchToNextPlayer();
                    }
                }
                // Update UI AFTER turn potentially switched and game state checked
                this.updateUI();
            }

            switchToNextPlayer() {
                if (this.activePlayers.size <= 1) {
                    if (!this.gameOver) this.checkWinCondition();
                    return;
                }
                let nextPlayer = this.currentPlayer;
                let attempts = 0;
                const maxAttempts = this.numPlayers + 1;
                do {
                    nextPlayer = (nextPlayer % this.numPlayers) + 1;
                    attempts++;
                    if (attempts > maxAttempts) {
                        console.error("Infinite loop detected in switchToNextPlayer! Ending game.");
                        this.gameOver = true; return;
                    }
                } while (!this.activePlayers.has(nextPlayer));
                this.currentPlayer = nextPlayer;
                console.log(`Switched to P${this.currentPlayer}`);
                // UI update (grid color change) happens in updateUI called by placeOrb
            }

            async explodeCell(r_initial, c_initial) {
                let explosionQueue = [{ r: r_initial, c: c_initial }];
                const projectileGeometry = new THREE.SphereGeometry(this.effectiveCellSize * PROJECTILE_RADIUS_FACTOR, PROJECTILE_DETAIL.segments, PROJECTILE_DETAIL.rings);
                const explosionSpeed = EXPLOSION_SPEED_FACTOR * this.effectiveCellSize;
                const explosionStartTime = Date.now(); // Start explosion timer

                while (explosionQueue.length > 0) {
                    // Exit if continuous explosions exceed 5 seconds
                    if (Date.now() - explosionStartTime >= 5000) {
                        console.log("Explosion chain exceeded 5 seconds. Exiting game.");
                        this.gameOver = true;
                        break; // Exit explosion loop
                    }
                    
                    const currentLevelExplosions = [];
                    const nextLevelQueue = [];
                    const cellsTriggeredThisLevel = new Set(); // Prevent multi-trigger in same wave

                    for (const { r, c } of explosionQueue) {
                        const cellState = this.board[r]?.[c];
                        if (!cellState || cellState.count < this.getCriticalMass(r, c) || cellState.owner === null) continue;

                        this.playSoundExplode();
                        const explodingPlayer = cellState.owner;
                        const startPos = this.getCellCenter(r, c);
                        const playerIndex = explodingPlayer - 1;
                        if (playerIndex < 0 || playerIndex >= this.playerColors.length) continue;

                        const color = this.playerColors[playerIndex];
                        // Create material for this specific explosion source (will be cloned for projectiles)
                        const material = new THREE.MeshLambertMaterial({ color: color, emissive: color, emissiveIntensity: 0.6 });

                        const cellKey = `${r}-${c}`;
                        if (this.orbGroups[cellKey]) {
                            this.gridGroup.remove(this.orbGroups[cellKey]);
                            this.disposeObject(this.orbGroups[cellKey]);
                            delete this.orbGroups[cellKey];
                        }
                        cellState.count = 0; cellState.owner = null; // Clear cell state

                        const neighbors = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }];
                        for (const { dr, dc } of neighbors) {
                            const nr = r + dr; 
                            const nc = c + dc;
                            if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) {
                                const neighborState = this.board[nr][nc];
                                const endPos = this.getCellCenter(nr, nc);
                                // Use shared geometry, clone material
                                const projectile = new THREE.Mesh(projectileGeometry, material.clone());
                                projectile.position.copy(startPos);
                                projectile.name = `Projectile_${r}-${c}_to_${nr}-${nc}`;
                                this.gridGroup.add(projectile);

                                const distance = startPos.distanceTo(endPos);
                                const duration = distance / explosionSpeed;

                                const animationPromise = this.animateProjectile(projectile, endPos, duration)
                                    .then(() => {
                                        if (projectile.parent) projectile.parent.remove(projectile);
                                        this.disposeObject(projectile); // Dispose projectile mesh/material clone

                                        neighborState.owner = explodingPlayer;
                                        neighborState.count++;
                                        this.renderCell(nr, nc); // Update captured cell visuals

                                        const neighborKey = `${nr}-${nc}`;
                                        if (neighborState.count >= this.getCriticalMass(nr, nc) && !cellsTriggeredThisLevel.has(neighborKey)) {
                                            nextLevelQueue.push({ r: nr, c: nc });
                                            cellsTriggeredThisLevel.add(neighborKey);
                                        }
                                    })
                                    .catch(error => {
                                        console.error("Projectile animation failed:", error);
                                        if (projectile.parent) projectile.parent.remove(projectile);
                                        this.disposeObject(projectile);
                                    });
                                currentLevelExplosions.push(animationPromise);
                            }
                        }
                        material.dispose(); // Dispose the source material for this explosion
                    } // End for loop

                    if (currentLevelExplosions.length > 0) await Promise.all(currentLevelExplosions);
                    if (nextLevelQueue.length > 0) await new Promise(resolve => setTimeout(resolve, EXPLOSION_DELAY_MS));
                    explosionQueue = nextLevelQueue;
                } // End while loop

                projectileGeometry.dispose(); // Dispose shared geometry after all explosions
                this.isExploding = false; // Re-enable input
                console.log("Explosion sequence finished.");
            }

            animateProjectile(mesh, targetPos, duration) {
                 return new Promise((resolve, reject) => {
                    if (!mesh || !targetPos || duration <= 0) return reject(new Error("Invalid projectile animation parameters"));
                    const startPos = mesh.position.clone();
                    let startTime = null;
                    const animate = (time) => {
                        if (!mesh || !mesh.parent) return resolve(); // Stop if mesh removed early
                        if (!startTime) startTime = time;
                        const elapsedTime = (time - startTime) / 1000;
                        const progress = Math.min(elapsedTime / duration, 1.0);
                        mesh.position.lerpVectors(startPos, targetPos, progress);
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    requestAnimationFrame(animate);
                });
            }

            checkPlayerElimination() {
                if (this.turnCount < this.numPlayers) return;
                const presentPlayers = new Set();
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        if (this.board[r][c].owner !== null) presentPlayers.add(this.board[r][c].owner);
                    }
                }
                const eliminated = [];
                for (const player of this.activePlayers) if (!presentPlayers.has(player)) eliminated.push(player);
                if (eliminated.length > 0) {
                    eliminated.forEach(player => {
                        this.activePlayers.delete(player);
                        console.log(`Player ${player} eliminated.`);
                    });
                }
            }

            checkWinCondition() {
                if (this.gameOver || this.turnCount < this.numPlayers) return;
                if (this.activePlayers.size === 1) {
                    this.gameOver = true;
                    console.log(`Game Over: Player ${[...this.activePlayers][0]} wins!`);
                } else if (this.activePlayers.size === 0) {
                    this.gameOver = true;
                    console.log("Game Over: Draw! (No active players left)");
                }
                // UI update showing game over state is handled in updateUI called by placeOrb
            }

            animate() {
                this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
                if (this.renderer && this.scene && this.camera) {
                    const deltaTime = this.clock.getDelta();
                    this.updateOrbAnimations(deltaTime);
                    this.renderer.render(this.scene, this.camera);
                }
            }

            updateOrbAnimations(deltaTime) {
                if (!this.gridGroup) return;
                const time = this.clock.getElapsedTime();
                
                // Update each orb group's animation
                Object.values(this.orbGroups).forEach(group => {
                    if (!group.userData?.basePositions) return;
                    
                    const { basePositions, animationSpeed, orbCount } = group.userData;
                    const orbs = group.children;
                    
                    // Orbital rotation
                    group.rotation.z = time * 0.5 * animationSpeed;
                    
                    // Individual orb animations
                    for (let i = 0; i < Math.min(orbCount, orbs.length); i++) {
                        const orb = orbs[i];
                        const basePos = basePositions[i];
                        
                        // Vibration effect
                        const vibrationAmplitude = 0.02 * animationSpeed;
                        const vibrationFrequency = 5 * animationSpeed;
                        const xOffset = Math.sin(time * vibrationFrequency + i * Math.PI * 2/3) * vibrationAmplitude;
                        const yOffset = Math.cos(time * vibrationFrequency + i * Math.PI * 2/3) * vibrationAmplitude;
                        
                        orb.position.x = basePos.x + xOffset;
                        orb.position.y = basePos.y + yOffset;
                        orb.position.z = basePos.z + Math.sin(time * 3 + i * Math.PI/2) * 0.01 * animationSpeed;
                    }
                });
            }

            onWindowResize() {
                // Handle window resizing for the game viewport and camera
                if (!this.renderer || !this.camera) return;
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.renderer.setSize(width, height);
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                
                // Always check if fullscreen button should be shown after resize
                this.checkAndShowFullscreenOption();
            }
            
            checkAndShowFullscreenOption() {
                // Only show fullscreen button on small devices or if fullscreen is available
                const isMobile = this.isMobileDevice();
                if (this.dom.fullscreenButton) {
                    if (isMobile && document.documentElement.requestFullscreen) {
                        this.dom.fullscreenButton.style.display = 'flex';
                    } else {
                        this.dom.fullscreenButton.style.display = 'none';
                    }
                }
            }
            
            isMobileDevice() {
                // More comprehensive check for mobile devices
                const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                const isMobileWidth = width < MOBILE_BREAKPOINT;
                const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                const isMobileUserAgent = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Device is considered mobile if it has a mobile width and either touch capability or mobile user agent
                return isMobileWidth && (hasTouchScreen || isMobileUserAgent);
            }
            
            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.warn(`Error attempting to enable fullscreen: ${err.message}`);
                    });
                    this.dom.fullscreenButton.textContent = 'Exit Fullscreen';
                    this.dom.fullscreenButton.classList.add('active');
                } else if (document.exitFullscreen) {
                    document.exitFullscreen();
                    this.dom.fullscreenButton.textContent = 'Fullscreen Mode';
                    this.dom.fullscreenButton.classList.remove('active');
                }
            }
            
            cleanup() {
                console.log("Cleaning up game resources...");
                if(this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
                this.dom.canvas.removeEventListener('pointerdown', this.boundOnCanvasInteraction);
                this.dom.canvas.removeEventListener('contextmenu',(e)=>e.preventDefault());

                if(this.audioContext && this.audioContext.state !== 'closed') {
                    this.audioContext.close().then(() => console.log("AudioContext closed.")).catch(e => console.error("Error closing AudioContext:", e));
                }
                this.audioContext = null; this.soundEnabled = false;

                if (this.scene) {
                    if (this.gridLineMaterial) this.gridLineMaterial.dispose();
                    while(this.scene.children.length > 0){
                        const object = this.scene.children[0];
                        this.scene.remove(object);
                        this.disposeObject(object); // Dispose geometry/material recursively
                    }
                }
                 if (this.renderer) {
                    this.renderer.dispose(); this.renderer.domElement = null;
                }

                this.scene = null; this.camera = null; this.renderer = null; this.raycaster = null; this.mouse = null;
                this.gridGroup = null; this.gridLineMaterial = null; this.gridPlaneMesh = null; this.orbGroups = {};
                this.board = []; this.activePlayers.clear();
                this.ambientLight = null; this.directionalLight = null;
                console.log("Cleanup complete.");
            }

             disposeObject(obj) {
                if (!obj) return;
                if (obj.children && obj.children.length > 0) {
                    [...obj.children].forEach(child => {
                        this.disposeObject(child);
                         // Don't necessarily remove from parent here, let the top-level removal handle hierarchy
                    });
                }
                 // Dispose geometry if it exists and belongs to this object
                if (obj.geometry && typeof obj.geometry.dispose === 'function') {
                    obj.geometry.dispose();
                }
                 // Dispose material(s) if they exist and belong to this object
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(material => {
                             if (material && typeof material.dispose === 'function') material.dispose();
                             // Dispose textures associated with the material
                             if (material && material.map && typeof material.map.dispose === 'function') material.map.dispose();
                             if (material && material.emissiveMap && typeof material.emissiveMap.dispose === 'function') material.emissiveMap.dispose();
                             // Add other map types if used (normalMap, bumpMap, etc.)
                         });
                    } else {
                         if (typeof obj.material.dispose === 'function') obj.material.dispose();
                         if (obj.material.map && typeof obj.material.map.dispose === 'function') obj.material.map.dispose();
                         if (obj.material.emissiveMap && typeof obj.material.emissiveMap.dispose === 'function') obj.material.emissiveMap.dispose();
                    }
                }
                 // Dispose textures directly attached to the object (less common)
                if (obj.texture && typeof obj.texture.dispose === 'function') {
                    obj.texture.dispose();
                }
                 // Remove from parent if applicable (safer done at higher level during scene cleanup)
                 // if (obj.parent) {
                 //     obj.parent.remove(obj);
                 // }
            }
        } // End ChainReactionGame Class

        // --- Instantiate ---
        document.addEventListener('DOMContentLoaded', () => {
            window.chainReactionGame = new ChainReactionGame();
        });
    </script>
</body>
</html>