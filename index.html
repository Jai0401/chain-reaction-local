<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction 3D (Mobile Friendly)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Base Styles */
        body { background-color: #000000; color: #e0e0e0; font-family: 'Arial', sans-serif; overflow: hidden; margin: 0; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        canvas { display: block; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }

        /* UI Panels */
        .ui-panel { position: absolute; left: 50%; transform: translateX(-50%); z-index: 10; background-color: rgba(30, 30, 30, 0.9); padding: 1.2rem 1rem; border-radius: 0.75rem; box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2); border: 1px solid rgba(0, 255, 255, 0.5); text-align: center; pointer-events: auto; display: flex; flex-direction: column; align-items: center; width: 90%; max-width: 450px; }
        #setup-screen { top: 50%; transform: translate(-50%, -50%); }
        #game-ui { top: 0.75rem; padding: 0.6rem 0.8rem; max-width: 90%; width: auto; min-width: 260px; display: none; }

        /* UI Elements */
        h2 { color: #ffffff; margin-bottom: 1rem; font-size: 1.3rem; }
        label { color: #00ffff; margin-right: 0.5rem; font-weight: bold; display: block; margin-bottom: 0.25rem; text-align: center; }
        select, button:not(#mute-button) { background-color: #222; color: #00ffff; border: 1px solid #00ffff; padding: 0.7rem 1.2rem; border-radius: 0.375rem; margin: 0.4rem; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s; font-weight: bold; width: 85%; max-width: 280px; box-sizing: border-box; -webkit-appearance: none; -moz-appearance: none; appearance: none; font-size: 0.9rem; }
        @media (hover: hover) and (pointer: fine) { select:hover, button:not(#mute-button):hover { background-color: #333; box-shadow: 0 0 10px #00ffff; } }
        select:focus, button:focus { outline: 2px solid #00ffff; outline-offset: 2px; }
        select { background-image: url('data:image/svg+xml;utf8,<svg fill="%2300ffff" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>'); background-repeat: no-repeat; background-position: right 0.7rem center; padding-right: 2.5rem; text-align: center; text-align-last: center; -moz-text-align-last: center; }

        /* Message Area */
        #message-area { min-height: 35px; padding: 0.5rem 0.7rem; margin-bottom: 0.5rem; font-weight: bold; font-size: 0.95rem; border-radius: 0.375rem; transition: all 0.3s; width: 100%; border: 1px solid transparent; display: flex; align-items: center; justify-content: center; box-sizing: border-box; line-height: 1.2; }

        /* Mute Button */
        #mute-button { position: absolute; top: 0.75rem; right: 0.75rem; z-index: 15; background-color: rgba(34, 34, 34, 0.8); color: #00ffff; border: 1px solid #00ffff; padding: 0.4rem; border-radius: 50%; font-size: 1rem; line-height: 1; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s; display: none; width: 36px; height: 36px; box-sizing: border-box; text-align: center; -webkit-appearance: none; -moz-appearance: none; appearance: none; display: flex; align-items: center; justify-content: center; }
        #mute-button.muted { color: #557777; border-color: #557777; background-color: rgba(34, 34, 34, 0.7); }
        @media (hover: hover) and (pointer: fine) { #mute-button:hover { background-color: #333; box-shadow: 0 0 8px #00ffff; } #mute-button.muted:hover { box-shadow: 0 0 8px #557777; border-color: #00ffff; color: #00ffff; } }

        /* Specific States */
        .winner-message { padding: 0.7rem; font-size: 1rem; animation: pulse 1.5s infinite; border-width: 2px; }
        @keyframes pulse { 0%{box-shadow:0 0 5px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} 50%{box-shadow:0 0 18px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} 100%{box-shadow:0 0 5px var(--player-color-css,#fff);border-color:var(--player-color-css,#fff)} }
        .hidden { display: none !important; }

        /* Setup Layout */
        .setup-row { display: flex; flex-direction: column; align-items: center; margin-bottom: 0.8rem; width: 100%; }
        .setup-row label { width: auto; text-align: center; margin-right: 0; margin-bottom: 0.15rem; }
        .setup-row select { flex-grow: 0; max-width: 280px; width: 85%; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="setup-screen" class="ui-panel">
            <h2>Game Setup</h2>
            <div class="setup-row">
                <label for="player-count">Players:</label>
                <select id="player-count">
                    <option value="2">2</option> <option value="3">3</option> <option value="4">4</option>
                    <option value="5">5</option> <option value="6">6</option> <option value="7">7</option> <option value="8">8</option>
                </select>
            </div>
            <div class="setup-row">
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <button id="start-game-button">Start Game</button>
        </div>
        <div id="game-ui" class="ui-panel"> <div id="message-area"></div> <button id="restart-button" class="hidden">Play Again?</button> </div>
        <div id="canvas-container"> <canvas id="game-canvas"></canvas> </div>
        <button id="mute-button" title="Toggle Sound">ðŸ”Š</button>
    </div>

    <script type="module">
        'use strict';
        // --- Constants ---
        // Add labels for dropdown display
        const GRID_SIZES = {
            SMALL:           { rows: 5, cols: 6, label: "Small (5x6)" },
            PORTRAIT_SMALL:  { rows: 6, cols: 5, label: "Portrait S (6x5)" }, // Mobile friendly
            MEDIUM:          { rows: 6, cols: 8, label: "Medium (6x8)" },
            PORTRAIT_MEDIUM: { rows: 8, cols: 6, label: "Portrait M (8x6)" }, // Mobile friendly
            LARGE:           { rows: 8, cols: 10, label: "Large (8x10)" }
        };
        const MOBILE_BREAKPOINT = 768; // Pixels: screens smaller than this get portrait default
        const DEFAULT_GRID_SIZE_DESKTOP = "MEDIUM";
        const DEFAULT_GRID_SIZE_MOBILE = "PORTRAIT_MEDIUM"; // Choose the default portrait size

        const BASE_CELL_SIZE = 10; // Reference size
        const GRID_GAP_FACTOR = 0.1;
        const ORB_RADIUS_FACTOR = 0.15;
        const ORB_DETAIL = { segments: 12, rings: 10 };
        const PROJECTILE_RADIUS_FACTOR = 0.12;
        const PROJECTILE_DETAIL = { segments: 10, rings: 8 };
        const EXPLOSION_DELAY_MS = 100;
        const EXPLOSION_SPEED_FACTOR = 7; // Speed relative to cell size
        const NEUTRAL_GRID_COLOR = 0x555555;
        const CAMERA_FOV = 50;
        const CAMERA_VIEW_PADDING = 1.1;
        const NEON_COLORS = [ 0x00ff00, 0x0088ff, 0xff0000, 0xffff00, 0x00ffff, 0xff00ff, 0xff8800, 0xffaaaa ];
        const NEON_COLORS_CSS = [ '#00ff00', '#0088ff', '#ff0000', '#ffff00', '#00ffff', '#ff00ff', '#ff8800', '#ffaaaa' ];

        class ChainReactionGame {
            dom = {};
            scene = null; camera = null; renderer = null; raycaster = null; mouse = null;
            gridGroup = null; gridLineMaterial = null; gridPlaneMesh = null;
            orbGroups = {};
            ambientLight = null; directionalLight = null;
            rows = 0; cols = 0; board = []; numPlayers = 2;
            playerColors = []; playerColorsCSS = []; currentPlayer = 1;
            isExploding = false; turnCount = 0; gameOver = false;
            activePlayers = new Set(); animationFrameId = null;
            effectiveCellSize = BASE_CELL_SIZE;
            effectiveGapSize = BASE_CELL_SIZE * GRID_GAP_FACTOR;
            cellStep = BASE_CELL_SIZE * (1 + GRID_GAP_FACTOR);
            gridTotalVisualWidth = 0; gridTotalVisualHeight = 0;
            audioContext = null; soundEnabled = false; isMuted = false;
            boundOnCanvasInteraction = this.onCanvasInteraction.bind(this);
            boundOnWindowResize = this.onWindowResize.bind(this);
            boundStartGame = this.startGame.bind(this);
            boundResetGame = this.resetGame.bind(this);
            boundToggleMute = this.toggleMute.bind(this);

            constructor() {
                if (!this.cacheDomElements()) { console.error("Essential DOM elements missing!"); return; }
                this.populateGridSizeDropdown(); // Populate before showing
                this.setDefaultGridSize();      // Set default based on screen size
                this.showSetupScreen();
                this.setupEventListeners();
                console.log("Chain Reaction Game Initialized (Mobile Friendly)");
            }

            cacheDomElements() {
                this.dom = {
                    setupScreen: document.getElementById('setup-screen'), gameUi: document.getElementById('game-ui'), playerCountSelect: document.getElementById('player-count'), gridSizeSelect: document.getElementById('grid-size'), startGameButton: document.getElementById('start-game-button'), messageArea: document.getElementById('message-area'), restartButton: document.getElementById('restart-button'), canvas: document.getElementById('game-canvas'), canvasContainer: document.getElementById('canvas-container'), gameContainer: document.getElementById('game-container'), muteButton: document.getElementById('mute-button')
                };
                // Check if critical elements exist, especially the grid size select
                return !!(this.dom.canvas && this.dom.canvasContainer && this.dom.setupScreen && this.dom.gameUi && this.dom.muteButton && this.dom.gridSizeSelect);
            }

            // --- Setup Helpers ---
            populateGridSizeDropdown() {
                const selectElement = this.dom.gridSizeSelect;
                if (!selectElement) return;
                selectElement.innerHTML = ''; // Clear existing options if any
                for (const key in GRID_SIZES) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = GRID_SIZES[key].label;
                    selectElement.appendChild(option);
                }
            }

            setDefaultGridSize() {
                const selectElement = this.dom.gridSizeSelect;
                if (!selectElement) return;
                const isMobile = window.innerWidth < MOBILE_BREAKPOINT;
                const defaultKey = isMobile ? DEFAULT_GRID_SIZE_MOBILE : DEFAULT_GRID_SIZE_DESKTOP;

                // Check if the default key exists in our GRID_SIZES
                if (GRID_SIZES[defaultKey]) {
                    selectElement.value = defaultKey;
                    console.log(`Setting default grid size to: ${defaultKey} (Mobile: ${isMobile})`);
                } else {
                    console.warn(`Default grid size key "${defaultKey}" not found. Using first option.`);
                    selectElement.selectedIndex = 0; // Fallback to the first option
                }
            }

            showSetupScreen() { this.dom.setupScreen.style.display = 'flex'; this.dom.gameUi.style.display = 'none'; this.dom.muteButton.style.display = 'none'; this.dom.restartButton.classList.add('hidden'); }
            setupEventListeners() { this.dom.startGameButton.addEventListener('click', this.boundStartGame); this.dom.restartButton.addEventListener('click', this.boundResetGame); window.addEventListener('resize', this.boundOnWindowResize); this.dom.muteButton.addEventListener('click', this.boundToggleMute); }

            // --- Game Lifecycle ---
            startGame() {
                this.initAudioContext();
                this.numPlayers = parseInt(this.dom.playerCountSelect.value, 10);
                const sizeKey = this.dom.gridSizeSelect.value;

                // Ensure the selected key is valid
                if (!GRID_SIZES[sizeKey]) {
                    console.error(`Invalid grid size key selected: ${sizeKey}. Defaulting to first available.`);
                    this.dom.gridSizeSelect.selectedIndex = 0; // Select first option
                    sizeKey = this.dom.gridSizeSelect.value; // Read the new value
                     if (!GRID_SIZES[sizeKey]) { // Still invalid? Serious issue.
                         alert("Error: Could not determine grid size."); return;
                     }
                }

                const size = GRID_SIZES[sizeKey];
                this.rows = size.rows; this.cols = size.cols;

                console.log(`Starting game: ${this.numPlayers}p, Grid ${sizeKey} (${this.rows}x${this.cols})`);
                this.dom.setupScreen.style.display = 'none'; this.dom.gameUi.style.display = 'flex'; this.dom.muteButton.style.display = 'flex';
                this.updateMuteButtonVisuals();
                this.initializeGameInternals();
            }

            resetGame() { console.log("Resetting game..."); this.cleanup(); this.showSetupScreen(); }

            initializeGameInternals() {
                this.playerColors = NEON_COLORS.slice(0, this.numPlayers); this.playerColorsCSS = NEON_COLORS_CSS.slice(0, this.numPlayers);
                this.orbGroups = {}; this.currentPlayer = 1; this.isExploding = false; this.turnCount = 0; this.gameOver = false;
                this.activePlayers = new Set(Array.from({ length: this.numPlayers }, (_, i) => i + 1));
                this.initializeBoardState();
                this.setupSceneAndRenderer();
                this.updateGridAndCameraScale(); // Initial calc
                this.setupGridVisuals();      // Initial draw
                this.renderBoard();
                this.updateUI(); this.dom.restartButton.classList.add('hidden');
                this.dom.canvas.addEventListener('pointerdown', this.boundOnCanvasInteraction);
                this.dom.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                this.animate();
                console.log("Game internals initialized.");
            }

            initializeBoardState() { this.board = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ owner: null, count: 0 }))); }

            setupSceneAndRenderer() {
                this.scene = new THREE.Scene();
                this.renderer = new THREE.WebGLRenderer({ canvas: this.dom.canvas, antialias: true, alpha: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.camera = new THREE.PerspectiveCamera(CAMERA_FOV, 1, 0.1, 5000); this.scene.add(this.camera);
                this.ambientLight = new THREE.AmbientLight(0xcccccc, 0.8); this.scene.add(this.ambientLight);
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); this.directionalLight.position.set(0.5, 1, 0.75).normalize(); this.scene.add(this.directionalLight);
                this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2();
            }

            // --- Dynamic Scaling & Positioning ---
            updateGridAndCameraScale() {
                if (!this.renderer || !this.camera || !this.dom.canvasContainer) return;
                const containerWidth = this.dom.canvasContainer.clientWidth; const containerHeight = this.dom.canvasContainer.clientHeight;
                const gapFactor = GRID_GAP_FACTOR;
                const availableWidth = containerWidth * 0.95; const availableHeight = containerHeight * 0.90;
                const totalWidthUnits = this.cols + (this.cols - 1) * gapFactor; const totalHeightUnits = this.rows + (this.rows - 1) * gapFactor;
                const cellSizeBasedOnWidth = availableWidth / totalWidthUnits; const cellSizeBasedOnHeight = availableHeight / totalHeightUnits;
                this.effectiveCellSize = Math.max(1, Math.min(cellSizeBasedOnWidth, cellSizeBasedOnHeight));
                this.effectiveGapSize = this.effectiveCellSize * gapFactor; this.cellStep = this.effectiveCellSize + this.effectiveGapSize;
                this.gridTotalVisualWidth = this.cols * this.effectiveCellSize + (this.cols - 1) * this.effectiveGapSize;
                this.gridTotalVisualHeight = this.rows * this.effectiveCellSize + (this.rows - 1) * this.effectiveGapSize;
                this.renderer.setSize(containerWidth, containerHeight); this.camera.aspect = containerWidth / containerHeight;
                const fovRad = THREE.MathUtils.degToRad(this.camera.fov); const tanFovHalf = Math.tan(fovRad / 2);
                const targetHeight = this.gridTotalVisualHeight * CAMERA_VIEW_PADDING; const distanceForHeight = (targetHeight / 2) / tanFovHalf;
                const targetWidth = this.gridTotalVisualWidth * CAMERA_VIEW_PADDING; const distanceForWidth = (targetWidth / 2) / (tanFovHalf * this.camera.aspect);
                const baseCameraZ = Math.max(distanceForHeight, distanceForWidth); const cameraZ = Math.max(baseCameraZ + this.effectiveCellSize, this.effectiveCellSize * 3);
                const gridCenterX = this.gridTotalVisualWidth / 2; const gridCenterY = this.gridTotalVisualHeight / 2;
                this.camera.position.set(gridCenterX, gridCenterY, cameraZ); this.camera.lookAt(gridCenterX, gridCenterY, 0);
                this.camera.updateProjectionMatrix();
                if (this.gridPlaneMesh) { this.updateGridPlaneGeometry(); }
                if (this.gridGroup) { this.setupGridVisuals(true); } // Update lines
                // console.log(`Grid Scale Update: CellSize=${this.effectiveCellSize.toFixed(2)}, GridVis=${this.gridTotalVisualWidth.toFixed(1)}x${this.gridTotalVisualHeight.toFixed(1)}, CamZ=${cameraZ.toFixed(1)}`);
            }

            updateGridPlaneGeometry() {
                 if (!this.gridPlaneMesh) return;
                 const planeWidth = this.gridTotalVisualWidth; const planeHeight = this.gridTotalVisualHeight;
                 const gridCenterX = planeWidth / 2; const gridCenterY = planeHeight / 2;
                 this.gridPlaneMesh.geometry.dispose();
                 this.gridPlaneMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                 this.gridPlaneMesh.position.set(gridCenterX, gridCenterY, -0.01);
            }

            // --- Grid Visuals ---
            setupGridVisuals(isUpdate = false) {
                if (this.gridGroup && !isUpdate) { this.scene.remove(this.gridGroup); this.disposeObject(this.gridGroup); this.gridGroup = null; this.gridPlaneMesh = null; }
                else if (this.gridGroup && isUpdate) { const linesToRemove = this.gridGroup.children.filter(child => child !== this.gridPlaneMesh); linesToRemove.forEach(line => { this.gridGroup.remove(line); this.disposeObject(line); }); }
                if (!isUpdate) {
                    this.gridGroup = new THREE.Group(); this.gridGroup.name = "GridGroup"; this.scene.add(this.gridGroup);
                    this.gridLineMaterial = new THREE.LineBasicMaterial({ color: NEUTRAL_GRID_COLOR, transparent: true, opacity: 0.7 });
                    const planeGeometry = new THREE.PlaneGeometry(1, 1); this.gridPlaneMesh = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide })); this.gridPlaneMesh.name = "GridPlane"; this.gridGroup.add(this.gridPlaneMesh); this.updateGridPlaneGeometry();
                }
                const maxX = this.gridTotalVisualWidth; const maxY = this.gridTotalVisualHeight;
                for (let i = 0; i <= this.cols; i++) { const x = i * this.cellStep - (this.effectiveGapSize / 2); const geom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, -this.effectiveGapSize/2, 0), new THREE.Vector3(x, maxY + this.effectiveGapSize/2, 0)]); this.gridGroup.add(new THREE.Line(geom, this.gridLineMaterial)); }
                for (let i = 0; i <= this.rows; i++) { const y = i * this.cellStep - (this.effectiveGapSize / 2); const geom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-this.effectiveGapSize/2, y, 0), new THREE.Vector3(maxX + this.effectiveGapSize/2, y, 0)]); this.gridGroup.add(new THREE.Line(geom, this.gridLineMaterial)); }
            }

            // --- Audio ---
            initAudioContext() { if(this.audioContext)return;try{window.AudioContext=window.AudioContext||window.webkitAudioContext;if(window.AudioContext){this.audioContext=new AudioContext();if(this.audioContext.state==='suspended'){console.log("AudioContext suspended, will try resume on interaction.");}this.soundEnabled=true;console.log("AudioContext initialized.");}else{console.warn("Web Audio API not supported.");this.soundEnabled=false;}}catch(e){console.error("Error creating AudioContext:",e);this.soundEnabled=false;}}
            playSound(t,f,d,v=0.3){if(this.isMuted||!this.soundEnabled||!this.audioContext)return;if(this.audioContext.state==='suspended'){this.audioContext.resume().then(()=>{console.log("AudioContext resumed.");this._executeSound(t,f,d,v);}).catch(e=>console.warn("AudioContext resume failed:",e));return;}if(this.audioContext.state==='running'){this._executeSound(t,f,d,v);}}
            _executeSound(t,f,d,v){try{const o=this.audioContext.createOscillator();const g=this.audioContext.createGain();o.connect(g);g.connect(this.audioContext.destination);o.type=t;o.frequency.setValueAtTime(f,this.audioContext.currentTime);g.gain.setValueAtTime(0,this.audioContext.currentTime);g.gain.linearRampToValueAtTime(v,this.audioContext.currentTime+0.01);g.gain.linearRampToValueAtTime(0,this.audioContext.currentTime+d);o.start(this.audioContext.currentTime);o.stop(this.audioContext.currentTime+d);}catch(e){console.error("Error playing sound:",e);}}
            playSoundPlace(){this.playSound('triangle',880,0.08,0.15);}
            playSoundExplode(){this.playSound('square',200,0.18,0.25);}
            toggleMute(){this.isMuted=!this.isMuted;console.log("Muted:",this.isMuted);this.updateMuteButtonVisuals();if(!this.isMuted&&this.audioContext&&this.audioContext.state==='suspended'){console.log("Attempting resume AudioContext on unmute.");this.audioContext.resume().catch(e=>console.warn("Resume on unmute failed:",e));}}
            updateMuteButtonVisuals(){if(!this.dom.muteButton)return;this.dom.muteButton.textContent=this.isMuted?'ðŸ”‡':'ðŸ”Š';this.dom.muteButton.classList.toggle('muted',this.isMuted);this.dom.muteButton.setAttribute('title',this.isMuted?'Unmute Sound':'Mute Sound');}

            // --- Game Logic & Rendering ---
            getCriticalMass=(r,c)=>{const iC=(r===0||r===this.rows-1)&&(c===0||c===this.cols-1);const iE=!iC&&(r===0||r===this.rows-1||c===0||c===this.cols-1);if(iC)return 2;if(iE)return 3;return 4;};
            getCellCenter(r,c){const x=c*this.cellStep+this.effectiveCellSize/2;const y=(this.rows-1-r)*this.cellStep+this.effectiveCellSize/2;return new THREE.Vector3(x,y,0);}

            renderCell(r, c) {
                if (!this.gridGroup || !this.board[r]?.[c]) return;
                const cellState = this.board[r][c]; const cellKey = `${r}-${c}`; const cellCenter = this.getCellCenter(r, c);
                if (this.orbGroups[cellKey]) { this.gridGroup.remove(this.orbGroups[cellKey]); this.disposeObject(this.orbGroups[cellKey]); delete this.orbGroups[cellKey]; }
                if (cellState.count > 0 && cellState.owner !== null) {
                    const playerIndex = cellState.owner - 1; if (playerIndex < 0 || playerIndex >= this.playerColors.length) return;
                    const color = this.playerColors[playerIndex]; const material = new THREE.MeshLambertMaterial({ color: color, emissive: color, emissiveIntensity: 0.4 });
                    const criticalMass = this.getCriticalMass(r, c); const scaleFactor = (cellState.count === criticalMass - 1) ? 1.15 : 1.0;
                    const radius = this.effectiveCellSize * ORB_RADIUS_FACTOR * scaleFactor; const orbGeometry = new THREE.SphereGeometry(radius, ORB_DETAIL.segments, ORB_DETAIL.rings);
                    const cellOrbGroup = new THREE.Group(); cellOrbGroup.position.copy(cellCenter); this.orbGroups[cellKey] = cellOrbGroup; this.gridGroup.add(cellOrbGroup);
                    const offset = this.effectiveCellSize * 0.18 * scaleFactor; const positions = [];
                    if (cellState.count === 1) positions.push(new THREE.Vector3(0, 0, radius*0.5));
                    else if (cellState.count === 2) { positions.push(new THREE.Vector3(-offset, 0, radius*0.4)); positions.push(new THREE.Vector3(offset, 0, radius*0.6)); }
                    else { const a=Math.PI*2/3; positions.push(new THREE.Vector3(0, offset, radius*0.5)); positions.push(new THREE.Vector3(offset*Math.sin(a), offset*Math.cos(a), radius*0.4)); positions.push(new THREE.Vector3(offset*Math.sin(a*2), offset*Math.cos(a*2), radius*0.6)); }
                    for (let i = 0; i < Math.min(cellState.count, 3); i++) { const orbMesh = new THREE.Mesh(orbGeometry, material); orbMesh.position.copy(positions[i]); orbMesh.name = `Orb_${r}-${c}_${i}`; cellOrbGroup.add(orbMesh); }
                    orbGeometry.dispose();
                }
            }

            renderBoard() { if (!this.board || !this.gridGroup) return; for(let r=0; r<this.rows; r++) for(let c=0; c<this.cols; c++) this.renderCell(r,c); }

            updateUI() { /* ... (UI update logic remains the same) ... */ if(!this.dom.messageArea||!this.gridLineMaterial)return;const m=this.dom.messageArea;const b=this.dom.restartButton;m.classList.remove('winner-message');m.style.cssText='';m.style.setProperty('--player-color-css','#ffffff');if(this.gameOver){this.gridLineMaterial.color.setHex(NEUTRAL_GRID_COLOR);m.classList.add('winner-message');b.classList.remove('hidden');if(this.activePlayers.size===1){const w=[...this.activePlayers][0];const i=w-1;const c=this.playerColorsCSS[i]||'#ffffff';m.textContent=`Player ${w} Wins!`;m.style.backgroundColor=c;m.style.color='#000000';m.style.borderColor=c;m.style.setProperty('--player-color-css',c);b.style.backgroundColor=c;b.style.borderColor=c;b.style.color='#000000';b.style.boxShadow=`0 0 10px ${c}`;}else{m.textContent=`Game Over! Draw or Error.`;m.style.backgroundColor='#555';m.style.color='#fff';m.style.borderColor='#777';m.style.setProperty('--player-color-css','#777');b.style.backgroundColor='';b.style.borderColor='';b.style.color='';b.style.boxShadow='';}}else{const i=this.currentPlayer-1;if(i<0||i>=this.playerColors.length){console.error("Invalid player index:",i);this.gridLineMaterial.color.setHex(NEUTRAL_GRID_COLOR);m.textContent="Error";m.style.backgroundColor='#ff0000';m.style.color='#ffffff';return;}const h=this.playerColors[i];const c=this.playerColorsCSS[i];this.gridLineMaterial.color.setHex(h);m.textContent=`Player ${this.currentPlayer}'s Turn`;const r=parseInt(c.slice(1),16);const R=(r>>16)&255;const G=(r>>8)&255;const B=r&255;m.style.backgroundColor=`rgba(${R},${G},${B},0.3)`;m.style.color=c;m.style.border=`1px solid ${c}`;m.style.boxShadow=`0 0 6px ${c}`;b.classList.add('hidden');b.style.backgroundColor='';b.style.borderColor='';b.style.color='';b.style.boxShadow='';}}

            // --- Player Interaction ---
            onCanvasInteraction(event) { /* ... (Interaction logic remains the same) ... */ if(this.isExploding||this.gameOver||!this.raycaster||!this.camera||!this.gridPlaneMesh||!event.isPrimary)return;event.preventDefault();const x=event.clientX;const y=event.clientY;const r=this.dom.canvas.getBoundingClientRect();this.mouse.x=((x-r.left)/r.width)*2-1;this.mouse.y=-((y-r.top)/r.height)*2+1;this.raycaster.setFromCamera(this.mouse,this.camera);const i=this.raycaster.intersectObject(this.gridPlaneMesh,false);if(i.length>0){const w=i[0].point;const l=this.gridGroup.worldToLocal(w.clone());const c=Math.floor(l.x/this.cellStep);const rv=Math.floor(l.y/this.cellStep);const R=this.rows-1-rv;if(R>=0&&R<this.rows&&c>=0&&c<this.cols){const C=this.board[R][c];if(C.owner===null||C.owner===this.currentPlayer){this.placeOrb(R,c);}else{console.log(`Cell (${R}, ${c}) owned by P${C.owner}.`);}}else{console.log(`Click outside grid (Local: ${l.x.toFixed(1)},${l.y.toFixed(1)} -> r:${R}, c:${c})`);}}}

            placeOrb(r,c){if(this.isExploding||this.gameOver)return;console.log(`P${this.currentPlayer} places at (${r}, ${c})`);this.playSoundPlace();this.turnCount++;const l=this.board[r][c];l.owner=this.currentPlayer;l.count++;this.renderCell(r,c);const m=this.getCriticalMass(r,c);if(l.count>=m){console.log(`Cell (${r}, ${c}) critical.`);this.isExploding=true;this.explodeCell(r,c);}else{this.checkPlayerElimination();this.checkWinCondition();if(!this.gameOver)this.switchToNextPlayer();this.updateUI();}}
            switchToNextPlayer(){if(this.activePlayers.size<=1){if(!this.gameOver){this.checkWinCondition();this.updateUI();}return;}let n=this.currentPlayer;let a=0;const m=this.numPlayers+1;do{n=(n%this.numPlayers)+1;a++;if(a>m){console.error("Infinite loop in switchToNextPlayer!");this.gameOver=true;return;}}while(!this.activePlayers.has(n));this.currentPlayer=n;console.log(`Switched to P${this.currentPlayer}`);}

            // --- Explosion Logic ---
            async explodeCell(r_initial, c_initial) { /* ... (Explosion logic remains the same) ... */ let q=[{r:r_initial,c:c_initial}];const g=new THREE.SphereGeometry(this.effectiveCellSize*PROJECTILE_RADIUS_FACTOR,PROJECTILE_DETAIL.segments,PROJECTILE_DETAIL.rings);const s=EXPLOSION_SPEED_FACTOR*this.effectiveCellSize;while(q.length>0){const t=[];const n=[];const p=new Set();for(const{r,c}of q){const l=this.board[r]?.[c];if(!l||l.count<this.getCriticalMass(r,c)||l.owner===null)continue;this.playSoundExplode();const E=l.owner;const S=this.getCellCenter(r,c);const I=E-1;if(I<0||I>=this.playerColors.length)continue;const C=this.playerColors[I];const M=new THREE.MeshLambertMaterial({color:C,emissive:C,emissiveIntensity:0.6});const k=`${r}-${c}`;if(this.orbGroups[k]){this.gridGroup.remove(this.orbGroups[k]);this.disposeObject(this.orbGroups[k]);delete this.orbGroups[k];}l.count=0;l.owner=null;const N=[{dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}];for(const{dr,dc}of N){const nr=r+dr;const nc=c+dc;if(nr>=0&&nr<this.rows&&nc>=0&&nc<this.cols){const L=this.board[nr][nc];const O=this.getCellCenter(nr,nc);const P=new THREE.Mesh(g,M.clone());P.position.copy(S);P.name=`Projectile_${r}-${c}_to_${nr}-${nc}`;this.gridGroup.add(P);const D=S.distanceTo(O);const U=D/s;const A=this.animateProjectile(P,O,U).then(()=>{if(P.parent)P.parent.remove(P);this.disposeObject(P);L.owner=E;L.count++;this.renderCell(nr,nc);const K=`${nr}-${nc}`;if(L.count>=this.getCriticalMass(nr,nc)&&!p.has(K)){n.push({r:nr,c:nc});p.add(K);}}).catch(e=>{console.error("Proj anim failed:",e);if(P.parent)P.parent.remove(P);this.disposeObject(P);});t.push(A);}}M.dispose();}if(t.length>0)await Promise.all(t);if(n.length>0)await new Promise(e=>setTimeout(e,EXPLOSION_DELAY_MS));q=n;}g.dispose();this.isExploding=false;console.log("Explosion finished.");this.checkPlayerElimination();this.checkWinCondition();if(!this.gameOver&&!this.activePlayers.has(this.currentPlayer)){console.log(`Player ${this.currentPlayer} eliminated, switching.`);this.switchToNextPlayer();}this.updateUI();}
            animateProjectile(m,t,d){return new Promise((s,f)=>{if(!m||!t||d<=0)return f(new Error("Invalid proj params"));const p=m.position.clone();let e=null;const c=a=>{if(!m||!m.parent)return s();if(!e)e=a;const n=(a-e)/1000;const o=Math.min(n/d,1.0);m.position.lerpVectors(p,t,o);if(o<1)requestAnimationFrame(c);else s();};requestAnimationFrame(c);});}

            // --- Game State Checks ---
            checkPlayerElimination(){if(this.turnCount<this.numPlayers)return;const p=new Set();for(let r=0;r<this.rows;r++)for(let c=0;c<this.cols;c++)if(this.board[r][c].owner!==null)p.add(this.board[r][c].owner);const t=[];for(const n of this.activePlayers)if(!p.has(n))t.push(n);if(t.length>0)t.forEach(e=>{this.activePlayers.delete(e);console.log(`Player ${e} eliminated.`);});}
            checkWinCondition(){if(this.gameOver||this.turnCount<this.numPlayers)return;if(this.activePlayers.size===1){this.gameOver=true;console.log(`Game Over: P${[...this.activePlayers][0]} wins!`);}else if(this.activePlayers.size===0){this.gameOver=true;console.log("Game Over: Draw!");}}

            // --- Animation Loop & Resize ---
            animate(){this.animationFrameId=requestAnimationFrame(this.animate.bind(this));if(this.renderer&&this.scene&&this.camera)this.renderer.render(this.scene,this.camera);}
            onWindowResize(){console.log("Window resize detected.");this.updateGridAndCameraScale();this.renderBoard();}

            // --- Cleanup ---
            cleanup() { /* ... (Cleanup logic remains the same) ... */ console.log("Cleaning up game resources...");if(this.animationFrameId)cancelAnimationFrame(this.animationFrameId);this.animationFrameId=null;this.dom.canvas.removeEventListener('pointerdown',this.boundOnCanvasInteraction);this.dom.canvas.removeEventListener('contextmenu',(e)=>e.preventDefault());if(this.audioContext&&this.audioContext.state!=='closed'){this.audioContext.close().then(()=>console.log("AudioContext closed.")).catch(e=>console.error("Err closing AudioContext:",e));}this.audioContext=null;this.soundEnabled=false;if(this.scene){if(this.gridLineMaterial)this.gridLineMaterial.dispose();while(this.scene.children.length>0){const o=this.scene.children[0];this.scene.remove(o);this.disposeObject(o);}}if(this.renderer){this.renderer.dispose();this.renderer.domElement=null;}this.scene=null;this.camera=null;this.renderer=null;this.raycaster=null;this.mouse=null;this.gridGroup=null;this.gridLineMaterial=null;this.gridPlaneMesh=null;this.orbGroups={};this.board=[];this.activePlayers.clear();this.ambientLight=null;this.directionalLight=null;console.log("Cleanup complete.");}
            disposeObject(o){if(!o)return;if(o.children&&o.children.length>0){[...o.children].forEach(c=>{this.disposeObject(c);if(o.remove)o.remove(c);});}if(o.geometry)o.geometry.dispose();if(o.material){if(Array.isArray(o.material))o.material.forEach(m=>m&&m.dispose());else o.material.dispose();}if(o.texture)o.texture.dispose();}

        } // End ChainReactionGame Class

        // --- Instantiate ---
        document.addEventListener('DOMContentLoaded', () => {
            window.chainReactionGame = new ChainReactionGame();
        });
    </script>
</body>
</html>